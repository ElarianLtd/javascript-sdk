<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils_doc.js.html":{"id":"utils_doc.js.html","title":"Source: utils/doc.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: utils/doc.js /* eslint-disable max-len */ /** * An object representing a tag. Tags can be used to group customers based on some similarities. e.g. loan defaulters, etc. * @typedef {Object} Tag * @property {string} key * @property {string} value * @property {number} [expiresAt] */ /** * An object representing a secondary id. Secondary Ids can be used to add some more unique identities to a customer. e.g. driver's license, etc. * @typedef {Object} SecondaryId * @property {string} key * @property {string} value */ /** * An object representing a customer number. * @typedef {Object} CustomerNumber * @property {string} number * @property {cellular|telegram|facebook|email|web} provider * @property {string} [partition] */ /** * An object representing a messaging channel number * @typedef {Object} MessagingChannelNumber * @property {string} number * @property {sms|telegram|whatsapp|email|messenger|voice} channel */ /** * An object representing media * @typedef {Object} Media * @property {string} url * @property {image|video|audio|document|voice|sticker|contact} type */ /** * An object representing location * @typedef {Object} Location * @property {double} latitude * @property {double} longitude * @property {string} label * @property {string} address */ /** * An object representing email * @typedef {Object} Email * @property {string} subject * @property {string} bodyPlain * @property {string} bodyHtml * @property {string[]} ccList * @property {string[]} bccList * @property {string[]} attachments */ /** * An object representing a message body * @typedef {Object} Body * @property {string} [text] * @property {Template} [template] * @property {Media} [media] * @property {Location} [location] * @property {Email} [email] * @property {string} [url] * @property {UssdMenu} [ussd] * @property {VoiceAction[]} [voice] */ /** * An object representing a message body * @typedef {Object} SimulatorMessageBody * @property {string} [text] * @property {Media} [media] * @property {Location} [location] * @property {Email} [email] * @property {string} [ussd] * @property {VoiceCallInput} [voice] */ /** * An object representing a voice call input * @typedef {Object} VoiceCallInput * @property {string} direction outbound or inbound * @property {string} status * @property {number} startedAt * @property {string} hangupCause * @property {string} dtmfDigits * @property {string} recordingUrl * @property {VoiceCallDialInput} dialData * @property {VoiceCallQueueInput} queueData */ /** * An object representing a voice call dial input * @typedef {Object} VoiceCallDialInput * @property {string} destinationNumber * @property {number} startedAt * @property {number} duration */ /** * An object representing a voice call queue input * @typedef {Object} VoiceCallQueueInput * @property {string} destinationNumber * @property {number} enqueuedAt * @property {number} dequeuedAt * @property {string} dequeuedToNumber * @property {string} dequeuedToSessionId * @property {number} queueDuration */ /** * An object representing a message reply prompt * @typedef {Object} PromptMenuItem * @property {string} [text] * @property {Media} [media] */ /** * An object representing a text template * @typedef {Object} Template * @property {string} id * @property {Object} params */ /** * An object representing a message reply prompt * @typedef {Object} ReplyPrompt * @property {string} action text, phone_number, email, location, url * @property {PromptMenuItem[]} menu */ /** * An object representing a message body * @typedef {Object} Message * @property {Body} body * @property {string[]} [labels] * @property {string} [providerTag] * @property {string} [replyToken] * @property {ReplyPrompt} [replyPrompt] */ /** * An object representing a customer activity * @typedef {Object} Activity * @property {string} sessionId * @property {string} key * @property {Object} [properties] */ /** * An object representing client params * @typedef {Object} ElarianConfig * @property {string} apiKey * @property {string} appId * @property {string} orgId * @property {string} [authToken] received from an client that authenticated with the API key. @see Elarian.generateAuthToken() * @property {boolean} [isSimulator] Run this client as a simulator * @property {boolean} [allowNotifications] allow this non-simulator client to receive notifications or not * @property {ConfigOptions} [options] setup connection options */ /** * An object representing serializer * @typedef {Object} Serializer * @property {text|binary} type * @property {function} serialize * @property {function} deserialize */ /** * An object representing config options * @typedef {Object} ConfigOptions * @property {number} [lifetime] * @property {number} [keepAlive] * @property {Serializer} [serializer] used to (de)serialize your metadata */ /** * An object representing cash * @typedef {Object} Cash * @property {double} amount * @property {string} currencyCode */ /** * An object representing wallet * @typedef {Object} Wallet * @property {string} customerId * @property {string} walletId */ /** * An object representing purse * @typedef {Object} Purse * @property {string} purseId */ /** * An object representing a payment channel * @typedef {Object} PaymentChannelNumber * @property {string} number * @property {string} channel number provider. Must be one of ['cellular'] */ /** * An object representing an activity channel number * @typedef {Object} ActivityChannelNumber * @property {string} number * @property {string} channel channel type. Must be one of ['web','modile'] */ /** * An object representing a payment transaction * @typedef {Object} PaymentTransaction * @property {string} transactionId * @property {string} appId * @property {CustomerPayment|Wallet|Purse} creditParty * @property {CustomerPayment|Wallet|Purse} debitParty * @property {Cash} value * @property {number} status * @property {number} createdAt * @property {number} updatedAt */ /** * An object representing a voice channel * @typedef {Object} VoiceChannelNumber * @property {string} number * @property {string} channel */ /** * An object representing a ussd channel * @typedef {Object} UssdChannelNumber * @property {string} number * @property {string} channel */ /** * An object representing a customer's payment source or destination * @typedef {Object} CustomerPayment * @property {CustomerNumber} customerNumber * @property {PaymentChannelNumber} channelNumber */ /** * An object representing customer params * @typedef {Object} CustomerParams * @property {Elarain} client * @property {CustomerNumber} customerNumber */ /** * An object representing a reminder * @typedef {Object} Reminder * @property {string} key * @property {number} remindAt timestamp in seconds * @property {string} payload * @property {number} [interval] */ /** * An object representing a ussd menu * @typedef {Object} UssdMenu * @property {string} text * @property {boolean} isTerminal */ /** * An object representing a 'say' voice action * @typedef {Object} Say * @property {string} text * @property {boolean} [playBeep] * @property {male|female} [voice] */ /** * An object representing a 'play' voice action * @typedef {Object} Play * @property {string} url */ /** * An object representing a 'getDigits' voice action * @typedef {Object} GetDigits * @property {number} timeout * @property {string} finishOnKey * @property {number} numDigits * @property {Say} [say] * @property {Play} [play] */ /** * An object representing a 'dial' voice action * @typedef {Object} Dial * @property {CustomerNumber[]} customerNumbers * @property {boolean} record * @property {boolean} sequential * @property {string} ringbackTone * @property {string} callerId * @property {number} maxDuration */ /** * An object representing a 'recordSession' voice action * @typedef {boolean} RecordSession */ /** * An object representing a 'reject' voice action * @typedef {boolean} Reject */ /** * An object representing a 'redirect' voice action * @typedef {Object} Redirect * @param {string} url */ /** * An object representing a 'enqueue' voice action * @typedef {Object} Enqueue * @param {string} queueName * @param {string} holdMusic */ /** * An object representing a 'dequeue' voice action * @typedef {Object} Dequeue * @param {string} queueName * @param {boolean} record * @param {ChannelNumber} channelNumber */ /** * An object representing a 'getRecording' voice action * @typedef {Object} GetRecording * @property {boolean} playBeep * @property {boolean} trimSilence * @property {number} timeout * @property {number} maxLength * @property {string} finishOnKey * @property {Say} [say] * @property {Play} [play] */ /** * An object representing a voice action. Note: Only one action is required in the object. * @typedef {Object} VoiceAction * @property {Say} say * @property {Play} play * @property {Dial} dial * @property {RecordSession} recordSession * @property {GetRecording} getRecording * @property {Enqueue} enqueue * @property {Dequeue} dequeue * @property {Reject} reject * @property {Redirect} redirect */ /** * Notification data * @typedef {Object} Notification * @property {Object} data * @property {Customer} customer */ /** * Notification callback * @typedef {function} NotificationCallback * @param {Error} error * @param {Message|UssdMenu|VoiceAction[]} [message] * @returns {void} */ /** * A function that reacts to events * @typedef {function} EventListener * @param {Notification} notification * @param {NotificationCallback} callback A response to the event. Required for voice and ussd events * @returns {void} */ /** * An string representing an event. Must be one of: * &lt;ul&gt; * &lt;li&gt;data&lt;/li&gt; * &lt;li&gt;--&lt;/li&gt; * &lt;li&gt;voiceCall&lt;/li&gt; * &lt;li&gt;ussdSession&lt;/li&gt; * &lt;li&gt;receivedSms&lt;/li&gt; * &lt;li&gt;receivedEmail&lt;/li&gt; * &lt;li&gt;receivedMessenger&lt;/li&gt; * &lt;li&gt;receivedTelegram&lt;/li&gt; * &lt;li&gt;receivedWhatsapp&lt;/li&gt; * &lt;li&gt;--&lt;/li&gt; * &lt;li&gt;sendMessage&lt;/li&gt; * &lt;li&gt;makeVoiceCall&lt;/li&gt; * &lt;li&gt;sendCustomerPayment&lt;/li&gt; * &lt;li&gt;sendChannelPayment&lt;/li&gt; * &lt;li&gt;checkoutPayment&lt;li&gt; * &lt;li&gt;--&lt;/li&gt; * &lt;li&gt;reminder&lt;/li&gt; * &lt;li&gt;messageStatus&lt;/li&gt; * &lt;li&gt;paymentStatus&lt;/li&gt; * &lt;li&gt;receivedPayment&lt;/li&gt; * &lt;li&gt;receivedMessage&lt;/li&gt; * &lt;li&gt;customerActivity&lt;/li&gt; * &lt;li&gt;walletPaymentStatus&lt;/li&gt; * &lt;li&gt;sentMessageReaction&lt;/li&gt; * &lt;li&gt;messagingSessionEnded&lt;/li&gt; * &lt;li&gt;messagingConsentUpdate&lt;/li&gt; * &lt;li&gt;messagingSessionStarted&lt;/li&gt; * &lt;li&gt;messagingSessionRenewed&lt;/li&gt; * &lt;/ul&gt; * @typedef {string} Event */ /** * * @typedef {Object} UpdateStatus * @property {string} customerId * @property {boolean} status * @property {string} description */ /** * * @typedef {Object} WorkStatus * @property {boolean} status * @property {string} description * @property {string} workId */ /** * * @typedef {Object} MessageStatus * @property {string} status * @property {string} description * @property {string} customerId * @property {string} messageId */ /** * * @typedef {Object} ConsentStatus * @property {string} status * @property {string} description * @property {string} customerId */ /** * * @typedef {string|*} LeasedAppData */ /** * * @typedef {Object} AuthToken * @property {string} token * @property {number} lifetime in seconds */ /** * * @typedef {Object} PaymentStatus * @property {number} status * @property {string} description * @property {string} transactionId * @property {string} debitCustomerId * @property {string} creditCustomerId */ /** * * @typedef {Object} VoiceStatus * @property {number} status * @property {string} description * @property {string} sessionId * @property {string} customerId */ × Search results Close "},"customer.js.html":{"id":"customer.js.html","title":"Source: customer.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: customer.js const validate = require('validate.js'); const { ElarianMessages, getValidCollectionKeys, } = require('./utils'); const { CustomerNumberProvider } = ElarianMessages; /** * A customer is your end-user, represented by a number (from a cellular, facebook or telegram) * @class * @param {CustomerParams} params */ function Customer(params) { const constraints = { customerId: { type: 'string', }, client: { type: 'object', presence: true, }, 'customerNumber.number': { type: 'string', }, 'customerNumber.provider': { type: 'string', inclusion: getValidCollectionKeys(CustomerNumberProvider), }, 'customerNumber.partition': { type: 'string', }, }; const error = validate(params, constraints); if (error) { let message = ''; Object.keys(error).forEach((key) =&gt; { message += `${key}: ${error[key].join(',')}\\n`; }); throw new Error(message); } this.client = params.client; this.customerId = params.customerId; this.customerNumber = params.customerNumber; this.identityState = {}; this.messagingState = {}; this.paymentState = {}; this.activityState = {}; /* eslint-disable no-use-before-define */ /** * Fetch the customer's current state. * @returns {CustomerState} */ this.getState = async () =&gt; { const data = await this.client.getCustomerState(this); this.customerId = data.customerId; const numbers = [ ...(data.messagingState ? data.messagingState.channels : []) .map((i) =&gt; Object.keys(i) .map((ki) =&gt; (i[ki] ? i[ki].customerNumber : null))).flat(), ...(data.paymentState ? data.paymentState.customerNumbers : []).map((i) =&gt; ({ ...i, state: 'payment' })), ]; if (numbers.length &amp;&amp; !this.customerNumber) { const candidate = numbers.find((i) =&gt; i.number); this.customerNumber = candidate; } this.identityState = data.identityState; this.paymentState = data.paymentState; this.messagingState = data.messagingState; this.activityState = data.activityState; return data; }; /** * Merge otherCustomer's state into this customer's state and discard otherCustomer * @param {Customer} otherCustomer * @returns {UpdateStatus} */ this.adoptState = async (otherCustomer) =&gt; this.client.adoptCustomerState(this, otherCustomer); /** * Update a customer's tag list. * @param {Tag[]} tags * @returns {UpdateStatus} */ this.updateTag = async (tags) =&gt; this.client.updateCustomerTag(this, tags); /** * Remove some tags from a customer * @param {Tag[]} tags * @returns {UpdateStatus} */ this.deleteTag = async (tags) =&gt; this.client.deleteCustomerTag(this, tags); /** * Update a customer's secondary Ids * @param {SecondaryId[]} secondaryIds * @returns {UpdateStatus} */ // eslint-disable-next-line max-len this.updateSecondaryId = async (secondaryIds) =&gt; this.client.updateCustomerSecondaryId(this, secondaryIds); /** * Remove some secondary Ids from a customer * @param {SecondaryId[]} secondaryIds * @returns {UpdateStatus} */ // eslint-disable-next-line max-len this.deleteSecondaryId = async (secondaryIds) =&gt; this.client.deleteCustomerSecondaryId(this, secondaryIds); /** * Set a reminder to be triggered at the specified time for a particular customer * @param {Reminder} reminder * @returns {UpdateStatus} */ this.addReminder = async (reminder) =&gt; this.client.addCustomerReminder(this, reminder); /** * Cancels a previously set reminder with the key &lt;code&gt;key&lt;/code&gt; on the customer * @param {string} key * @returns {UpdateStatus} */ this.cancelReminder = async (key) =&gt; this.client.cancelCustomerReminder(this, key); /** * Sets some metadata on the customer. * Values in the metadata object can either be strings or buffers, * depending on the set serializer * @param {Object} metadata * @returns {UpdateStatus} */ this.updateMetadata = async (metadata) =&gt; this.client.updateCustomerMetadata(this, metadata); /** * Remove some metadata from a customer. &lt;code&gt;keys&lt;/code&gt; is an array of strings * @param {string[]} keys * @returns {UpdateStatus} */ this.deleteMetadata = async (keys) =&gt; this.client.deleteCustomerMetadata(this, keys); /** * Sets some app data on the customer. * Values in the data object can either be strings or buffers, * depending on the set serializer * @param {Object} data * @returns {UpdateStatus} */ this.updateAppData = async (data) =&gt; this.client.updateCustomerAppData(this, data); /** * Fetches the customer's app data and lock it from fetching(for up to &lt;b&gt;90s&lt;/b&gt;) * until next call to update app data. * @returns {LeasedAppData} */ this.leaseAppData = async () =&gt; this.client.leaseCustomerAppData(this); /** * Remove customer's app data * @returns {UpdateStatus} */ this.deleteAppData = async () =&gt; this.client.deleteCustomerAppData(this); /** * Send a message to the customer from the specified channel number. * @param {MessagingChannelNumber} channelNumber * @param {Body} body * @returns {MessageStatus} */ // eslint-disable-next-line max-len this.sendMessage = async (channelNumber, body) =&gt; this.client.sendMessage(this, channelNumber, body); /** * Initiate a voice call to the customer * @param {string} channelNumber * @param {VoiceAction[]} actions * @returns {MessageStatus} */ // eslint-disable-next-line max-len this.makeVoiceCall = async (channelNumber, actions = []) =&gt; this.client.makeVoiceCall(this, channelNumber, actions); /** * Allow or block a customer from receiving messages from a channel * @param {MessagingChannelNumber} channelNumber * @param {string} action allow or block * @returns {ConsentStatus} */ // eslint-disable-next-line max-len this.updateMessagingConsent = async (channelNumber, action) =&gt; this.client.updateMessagingConsent(this, channelNumber, action); /** * Initiate a customer activity * @param {ActivityChannelNumber} channelNumber * @param {Activity} sessionId * @returns {UpdateStatus} */ // eslint-disable-next-line max-len this.updateActivity = async (channelNumber, activity) =&gt; this.client.updateCustomerActivity(this.customerNumber, channelNumber, activity); /* eslint-enable no-use-before-define */ /** * Initiate a payment transaction * @param {PaymentChannelNumber|Wallet} source * @param {Wallet|Purse} destination * @param {Cash} value * @returns {PaymentStatus} */ this.requestPayment = async (source, destination, value) =&gt; { if (!this.customerId &amp;&amp; (source.walletId || destination.walletId)) { const state = await this.getState(); this.customerId = state.customerId; } let debitParty = source; if (debitParty.number) { debitParty = { customerNumber: this.customerNumber, channelNumber: source, }; } else if (debitParty.walletId) { debitParty.customerId = this.customerId; } const creditParty = destination; if (creditParty.walletId) { creditParty.customerId = this.customerId; } return this.client.initiatePayment(debitParty, creditParty, value); }; } module.exports = Customer; × Search results Close "},"client.js.html":{"id":"client.js.html","title":"Source: client.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: client.js /* global window */ /* eslint-disable no-underscore-dangle */ const validate = require('validate.js'); const { connectRSocket } = require('./utils'); const defaultConfigOptions = { lifetime: 60000, keepAlive: 1000, reconnectInterval: 1000, serializer: { type: 'text', serialize: (data) =&gt; JSON.stringify(data), deserialize: (data) =&gt; { try { return JSON.parse(data); } catch (err) { this.platform.log.error(err); } return data; }, }, }; /** * Instantiate an elarian client. You have to call connect() on then client to start using it * @class * @param {ElarianConfig} config */ function Elarian(config) { const opts = { ...config, }; const constraints = { appId: { type: 'string', presence: true, }, orgId: { type: 'string', presence: true, }, apiKey: { type: 'string', }, authToken: { type: 'string', presence: this.platform.isBrowser, }, allowNotifications: { type: 'boolean', }, isSimulator: { type: 'boolean', }, options: { type: 'object', }, }; const error = validate(opts, constraints); if (error) { throw error; } this.options = opts; const configOpts = opts.options || {}; this.configOptions = { lifetime: configOpts.lifetime || defaultConfigOptions.lifetime, keepAlive: configOpts.keepAlive || defaultConfigOptions.keepAlive, serializer: configOpts.serializer || defaultConfigOptions.serializer, reconnectInterval: configOpts.reconnectInterval || defaultConfigOptions.reconnectInterval, }; this.eventListeners = { data: null, // Simulator sendMessage: null, makeVoiceCall: null, checkoutPayment: null, sendChannelPayment: null, sendCustomerPayment: null, // App (core) reminder: null, messageStatus: null, paymentStatus: null, receivedPayment: null, receivedMessage: null, customerActivity: null, sentMessageReaction: null, walletPaymentStatus: null, messagingSessionEnded: null, messagingConsentUpdate: null, messagingSessionStarted: null, messagingSessionRenewed: null, // App (virtual) voiceCall: null, ussdSession: null, receivedSms: null, receivedEmail: null, receivedWhatsapp: null, receivedTelegram: null, receivedMessenger: null, }; /** * Connect to the elarian server */ this.connect = async function connect() { const { client, socket } = await connectRSocket({ ...this.options, authToken: this.options.authToken, apiKey: this.options.authToken ? null : this.options.apiKey, }, { ...this.configOptions, platform: this.platform, notificationHandler: this.notificationHandler(this), }); this._client = client; this._socket = socket; }; this.getSocket = function getSocket() { if (!this._socket) { throw new Error('Client is not connected'); } return this._socket; }; /** * Disconnect from the elarian server */ this.disconnect = function disconnect() { if (this._client) { this._client.close(); } }; const cleanup = (code) =&gt; { this.platform.log.warn(`Disconnecting from API server(${code})`); this.disconnect(); if (!this.platform.isBrowser) { process.exit(code); } }; if (this.platform.isBrowser) { window.onbeforeunload = cleanup; } else { process.on('SIGINT', cleanup.bind(null)); process.on('SIGQUIT', cleanup.bind(null)); process.on('SIGTERM', cleanup.bind(null)); } } /** * Instantiate and connect an elarian client * @param {ElarianConfig} config */ Elarian.newInstance = async (config) =&gt; { const client = new Elarian(config); await client.connect(); return client; }; module.exports = Elarian; × Search results Close "},"state.js.html":{"id":"state.js.html","title":"Source: state.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: state.js const Elarian = require('./client'); const Customer = require('./customer'); const { addTag, addIndices, addCustomer, addReminder, ElarianMessages, addOtherCustomer, addCustomerNumber, addCustomerIndices, getChannelProvider, getCustomerNumberProviderString, getChannelProviderString, } = require('./utils'); const { DataMapValue, AppToServerCommand, AppToServerCommandReply, PaymentChannel, ActivityChannel, MessagingChannel, ActivityChannelNumber, CustomerActivityCommand, GetCustomerStateCommand, DeleteCustomerTagCommand, UpdateCustomerTagCommand, AdoptCustomerStateCommand, AddCustomerReminderCommand, LeaseCustomerAppDataCommand, DeleteCustomerAppDataCommand, DeleteCustomerMetadataCommand, UpdateCustomerAppDataCommand, CancelCustomerReminderCommand, AddCustomerReminderTagCommand, UpdateCustomerMetadataCommand, DeleteCustomerSecondaryIdCommand, UpdateCustomerSecondaryIdCommand, CancelCustomerReminderTagCommand, } = ElarianMessages; /** * Fetch the customer's current state. * @param {Customer} customer * @returns {CustomerState} * @memberof Elarian */ Elarian.prototype.getCustomerState = function getCustomerState(customer) { if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } const socket = this.getSocket(); let cmd = new GetCustomerStateCommand(); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setGetCustomerState(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getGetCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), data: (res.getData() || { toObject: () =&gt; undefined, }).toObject(), }; if (!result.status) { throw new Error(result.description); } // TODO: Clean up paymentState, messagingState, identityState // eslint-disable-next-line max-len if (result.data.identityState &amp;&amp; Object.keys(result.data.identityState).length) { const { serializer: { type, deserialize } } = this.configOptions; const deserializeKey = type === 'text' ? 'stringVal' : 'bytesVal'; const unprocessedState = result.data.identityState; const identityState = { tags: unprocessedState.tagsList.map((i) =&gt; ({ key: i.mapping.key, value: i.mapping.value.value, expiration: i.expiresAt.seconds, })), secondaryIds: unprocessedState.secondaryIdsList.map((i) =&gt; ({ key: i.mapping.key, value: i.mapping.value.value, expiration: i.expiresAt.seconds, })), metadata: Object.assign( {}, ...unprocessedState.metadataMap.map((i) =&gt; ({ [i[0]]: deserialize(i[1][deserializeKey]), })), ), }; result.data.identityState = identityState; } if (result.data.paymentState) { const entry = result.data.paymentState; result.data.paymentState = { wallets: entry.walletsMap, transactionLogs: entry.transactionLogList, pendingTransactions: entry.pendingTransactionsList, customerNumbers: entry.customerNumbersList.map((i) =&gt; ({ number: i.number, provider: getCustomerNumberProviderString(i.provider), })), channelNumbers: entry.channelNumbersList.map((i) =&gt; ({ number: i.number, channel: getChannelProviderString(i.channel, PaymentChannel), })), }; } if (result.data.messagingState) { result.data.messagingState = { channels: result.data.messagingState.channelsList.map((ch) =&gt; { const state = { active: ch.active, blocked: ch.blocked, inSession: ch.inSession, }; Object.keys(state).forEach((key) =&gt; { if (state[key]) { // customer+channel numbers state[key].customerNumber = state[key].customerNumber ? { number: state[key].customerNumber.number, provider: getCustomerNumberProviderString( state[key].customerNumber.provider, ), } : undefined; state[key].channelNumber = state[key].channelNumber ? { number: state[key].channelNumber.number, channel: getChannelProviderString( state[key].channelNumber.channel, MessagingChannel, ), } : undefined; } }); return state; }), }; } resolve(result.data); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Adopt another customer's state * @param {Customer} customer * @param {Customer} otherCustomer * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.adoptCustomerState = async function adoptCustomerState(customer, otherCustomer) { const socket = this.getSocket(); if (!(customer instanceof Customer) || !(otherCustomer instanceof Customer)) { throw new Error('Invalid customer and/or otherCustomer'); } let { customerId } = customer; if (!customerId) { const state = await customer.getState(); customerId = state.customerId; } let cmd = new AdoptCustomerStateCommand() .setCustomerId(customerId); cmd = addOtherCustomer(cmd, otherCustomer); const req = new AppToServerCommand() .setAdoptCustomerState(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Update a customer's tag list * @param {Customer} customer * @param {Tag[]} tags * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.updateCustomerTag = function updateCustomerTag(customer, tags) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!tags || !tags.length) { throw new Error('tags is required'); } let cmd = new UpdateCustomerTagCommand(); cmd = addCustomer(cmd, customer); cmd = addCustomerIndices(cmd, tags, 'setUpdatesList'); const req = new AppToServerCommand() .setUpdateCustomerTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Remove tags from a customer * @param {Customer} customer * @param {string[]} tags * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.deleteCustomerTag = async function deleteCustomerTag(customer, tags) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!tags || !tags.length) { throw new Error('tags is required'); } let cmd = new DeleteCustomerTagCommand() .setDeletionsList(tags); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setDeleteCustomerTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Update a customer's secondary Ids * @param {Customer} customer * @param {SecondaryId[]} secondaryIds * @returns {UpdateStatus} * @memberof Elarian */ // eslint-disable-next-line max-len Elarian.prototype.updateCustomerSecondaryId = async function updateCustomerSecondaryId(customer, secondaryIds) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!secondaryIds || !secondaryIds.length) { throw new Error('secondaryIds is required'); } let cmd = new UpdateCustomerSecondaryIdCommand(); cmd = addCustomer(cmd, customer); cmd = addCustomerIndices(cmd, secondaryIds, 'setUpdatesList'); const req = new AppToServerCommand() .setUpdateCustomerSecondaryId(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Delete a customer's secondary Ids * @param {Customer} customer * @param {SecondaryId[]} secondaryIds * @returns {UpdateStatus} * @memberof Elarian */ // eslint-disable-next-line max-len Elarian.prototype.deleteCustomerSecondaryId = function deleteCustomerSecondaryId(customer, secondaryIds) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!secondaryIds || !secondaryIds.length) { throw new Error('secondaryIds is required'); } let cmd = new DeleteCustomerSecondaryIdCommand(); cmd = addCustomer(cmd, customer); cmd = addIndices(cmd, secondaryIds, 'setDeletionsList'); const req = new AppToServerCommand() .setDeleteCustomerSecondaryId(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Set a reminder to be triggered at the specified time for a particular customer * @param {Customer} customer * @param {Reminder} reminder * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.addCustomerReminder = function addCustomerReminder(customer, reminder) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!reminder) { throw new Error('reminder is required'); } let cmd = new AddCustomerReminderCommand(); cmd = addCustomer(cmd, customer); cmd = addReminder(cmd, reminder); const req = new AppToServerCommand() .setAddCustomerReminder(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Cancels a previously set reminder with the key &lt;code&gt;key&lt;/code&gt; on the customer * @param {Customer} customer * @param {string} key * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.cancelCustomerReminder = function cancelCustomerReminder(customer, key) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!key) { throw new Error('key is required'); } let cmd = new CancelCustomerReminderCommand() .setKey(key); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setCancelCustomerReminder(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Set a reminder to be triggered at the specified time for customers with the particular tag * @param {Tag} tag * @param {Reminder} reminder * @returns {WorkStatus} * @memberof Elarian */ Elarian.prototype.addCustomerReminderByTag = function addCustomerReminderByTag(tag, reminder) { const socket = this.getSocket(); if (!reminder || !tag) { throw new Error('reminder and tag are required'); } let cmd = new AddCustomerReminderTagCommand(); cmd = addTag(cmd, tag); cmd = addReminder(cmd, reminder); const req = new AppToServerCommand() .setAddCustomerReminderTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getTagCommand(); const result = { status: res.getStatus(), description: res.getDescription(), workId: (res.getWorkId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Cancels a previously set reminder with tag &lt;code&gt;tag&lt;/code&gt; and key &lt;code&gt;key&lt;/code&gt; * @param {Tag} tag * @param {string} key * @returns {WorkStatus} * @memberof Elarian */ Elarian.prototype.cancelCustomerReminderByTag = function cancelCustomerReminderByTag(tag, key) { const socket = this.getSocket(); if (!key || !tag) { throw new Error('key and tag are required'); } let cmd = new CancelCustomerReminderTagCommand() .setKey(key); cmd = addTag(cmd, tag); const req = new AppToServerCommand() .setCancelCustomerReminderTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getTagCommand(); const result = { status: res.getStatus(), description: res.getDescription(), workId: (res.getWorkId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Sets some metadata on the customer. * Values in the metadata object can either be strings or buffers, * depending on your serializer. @see {@link Client} * @param {Customer} customer * @param {Object} metadata * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.updateCustomerMetadata = function updateCustomerMetadata(customer, metadata) { const socket = this.getSocket(); const { serializer } = this.configOptions; if (!metadata) { throw new Error('metadata is required'); } let cmd = new UpdateCustomerMetadataCommand(); cmd = addCustomer(cmd, customer); Object.keys(metadata).forEach((key) =&gt; { const value = new DataMapValue(); const serializedValue = serializer.serialize(metadata[key]); switch (serializer.type) { case 'text': value.setStringVal(serializedValue); break; case 'binary': value.setBytesValue(serializedValue); break; default: throw new Error('Invalid serializer type'); } cmd.getUpdatesMap().set(key, value); }); const req = new AppToServerCommand() .setUpdateCustomerMetadata(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Remove some metadata from a customer. * @param {Customer} customer * @param {string[]} keys * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.deleteCustomerMetadata = function deleteCustomerMetadata(customer, keys) { const socket = this.getSocket(); if (!keys || !keys.length) { throw new Error('keys are required'); } let cmd = new DeleteCustomerMetadataCommand() .setDeletionsList(keys); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setDeleteCustomerMetadata(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Sets some app data on the customer. * Value of the data object can either be a string or a buffer, * depending on your serializer. @see {@link Client} * @param {Customer} customer * @param {Object} data * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.updateCustomerAppData = function updateCustomerAppData(customer, data) { const socket = this.getSocket(); const { serializer } = this.configOptions; if (!data) { throw new Error('data is required'); } let cmd = new UpdateCustomerAppDataCommand(); cmd = addCustomer(cmd, customer); const appData = new DataMapValue(); const serializedValue = serializer.serialize(data); switch (serializer.type) { case 'text': appData.setStringVal(serializedValue); break; case 'binary': appData.setBytesValue(serializedValue); break; default: throw new Error('Invalid serializer type'); } cmd.setUpdate(appData); const req = new AppToServerCommand() .setUpdateCustomerAppData(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Fetches the customer's app data and lock it from fetching(for up to &lt;b&gt;90s&lt;/b&gt;) * until next call to update app data. * @param {Customer} customer * @returns {LeasedAppData} * @memberof Elarian */ Elarian.prototype.leaseCustomerAppData = function leaseCustomerAppData(customer) { const socket = this.getSocket(); const { serializer } = this.configOptions; let cmd = new LeaseCustomerAppDataCommand(); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setLeaseCustomerAppData(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getLeaseCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), value: (res.getValue() || { toObject: () =&gt; undefined, }).toObject(), }; if (!result.status) { throw new Error(result.description); } if (result.value) { const item = serializer.type === 'text' ? result.value.stringVal : result.value.bytesVal; result.value = serializer.deserialize(item); } resolve(result.value); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Remove customer's app data. * @param {Customer} customer * @returns {UpdateStatus} * @memberof Elarian */ Elarian.prototype.deleteCustomerAppData = function deleteCustomerAppData(customer) { const socket = this.getSocket(); let cmd = new DeleteCustomerAppDataCommand(); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setDeleteCustomerAppData(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Initiate a customer activity * @param {CustomerNumber} customerNumber * @param {ActivityChannelNumber} channelNumber * @param {Activity} activity * @returns {UpdateStatus} * @memberof Elarian */ // eslint-disable-next-line max-len Elarian.prototype.updateCustomerActivity = function updateCustomerActivity(customerNumber, channelNumber, activity) { const socket = this.getSocket(); const { sessionId, key, properties = {}, } = activity; let cmd = new CustomerActivityCommand(); cmd = cmd .setSessionId(sessionId) .setKey(key) .setChannelNumber( new ActivityChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, ActivityChannel)), ); Object.keys(properties).forEach((name) =&gt; { cmd.getPropertiesMap().set(name, properties[name]); }); cmd = addCustomerNumber(cmd, customerNumber); const req = new AppToServerCommand() .setCustomerActivity(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (item) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(item.data) .getCustomerActivity(); const result = { status: res.getStatus(), description: res.getDescription(), transactionId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"authentication.js.html":{"id":"authentication.js.html","title":"Source: authentication.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: authentication.js const Elarian = require('./client'); const { ElarianMessages } = require('./utils'); const { AppToServerCommand, AppToServerCommandReply, GenerateAuthTokenCommand, } = ElarianMessages; /** * Generate a short-lived auth token to use instead of apiKey. Used for browser and mobile clients. * @returns {AuthToken} * @memberof Elarian */ Elarian.prototype.generateAuthToken = function generateAuthToken() { const socket = this.getSocket(); const cmd = new GenerateAuthTokenCommand(); const req = new AppToServerCommand() .setGenerateAuthToken(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getGenerateAuthToken(); const result = { token: res.getToken(), lifetime: res.getLifetime().getSeconds(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"payment.js.html":{"id":"payment.js.html","title":"Source: payment.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: payment.js const { ElarianMessages, addCashValue, addPaymentCounterParty, getStatusString, } = require('./utils'); const Elarian = require('./client'); const { PaymentStatus, AppToServerCommand, AppToServerCommandReply, InitiatePaymentCommand, } = ElarianMessages; /** * Initiate a payment transaction * @param {CustomerPayment|Wallet|Purse} debitParty * @param {CustomerPayment|Wallet|Purse} creditParty * @param {Cash} value * @returns {PaymentStatus} * @memberof Elarian */ Elarian.prototype.initiatePayment = function initiatePayment(debitParty, creditParty, value) { const socket = this.getSocket(); let cmd = new InitiatePaymentCommand(); cmd = addPaymentCounterParty(cmd, debitParty, 'setDebitParty'); cmd = addPaymentCounterParty(cmd, creditParty, 'setCreditParty'); cmd = addCashValue(cmd, value); const req = new AppToServerCommand() .setInitiatePayment(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (item) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(item.data) .getInitiatePayment(); const result = { status: getStatusString(res.getStatus(), PaymentStatus), description: res.getDescription(), transactionId: (res.getTransactionId() || { getValue: () =&gt; undefined, }).getValue(), debitCustomerId: (res.getDebitCustomerId() || { getValue: () =&gt; undefined, }).getValue(), creditCustomerId: (res.getCreditCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"voice.js.html":{"id":"voice.js.html","title":"Source: voice.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: voice.js const { addCustomer, ElarianMessages, getMessageDeliveryStatusString, addVoiceCallActions, } = require('./utils'); const Elarian = require('./client'); const Customer = require('./customer'); const { OutboundMessage, MessagingChannel, SendMessageCommand, AppToServerCommand, OutboundMessageBody, MessagingChannelNumber, AppToServerCommandReply, VoiceCallDialplanMessageBody, } = ElarianMessages; /** * Initiate a voice call to customer from channelNumber * @param {Customer} customer * @param {string} channelNumber * @param {VoiceAction[]} actions * @returns {VoiceStatus} * @memberof Elarian */ Elarian.prototype.makeVoiceCall = function makeVoiceCall(customer, channelNumber, actions = []) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } const { customerNumber } = customer; if (!customerNumber) { // FIXME: Have Elarian return the customer number on fetch state? throw new Error('customerNumber is not setup on this customer'); } let cmd = new SendMessageCommand() .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber) .setChannel(MessagingChannel.MESSAGING_CHANNEL_VOICE), ); cmd = addCustomer(cmd, customer); const message = new OutboundMessage(); const messageBody = new OutboundMessageBody(); const dialPlan = addVoiceCallActions(new VoiceCallDialplanMessageBody(), actions); messageBody.setVoice(dialPlan); message.setBody(messageBody); cmd.setMessage(message); const req = new AppToServerCommand() .setSendMessage(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getSendMessage(); const result = { status: getMessageDeliveryStatusString(res.getStatus()), description: res.getDescription(), sessionId: (res.getSessionId() || { getValue: () =&gt; undefined, }).getValue(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"notification.js.html":{"id":"notification.js.html","title":"Source: notification.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: notification.js /* eslint-disable max-len */ const { Single } = require('rsocket-flowable'); const Elarian = require('./client'); const Customer = require('./customer'); const { ElarianMessages, addMessage, getStatusString, getMediaTypeString, getChannelProviderString, getMessageReactionString, getCustomerEventDirectionString, getCustomerNumberProviderString, getMessageSessionEndReasonString, getMessageConsentUpdateActionString, } = require('./utils'); const { PaymentStatus, PaymentChannel, ActivityChannel, MessagingChannel, VoiceCallStatus, VoiceCallHangupCause, MessageDeliveryStatus, ServerToAppNotification, MessagingConsentUpdateStatus, ServerToAppNotificationReply, ServerToSimulatorNotification, ServerToSimulatorNotificationReply, } = ElarianMessages; const cleanUpNotificationPayload = (event, data) =&gt; { /* eslint-disable no-param-reassign */ switch (event) { // App case 'reminder': data.reminder.payload = data.reminder.payload.value; data.reminder.remindAt = data.reminder.remindAt.seconds; data.reminder.interval = data.reminder.interval ? data.reminder.interval.seconds : undefined; break; case 'messagingSessionStarted': case 'messagingSessionRenewed': case 'messagingSessionEnded': data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; if (data.expiresAt) { data.expiresAt = data.expiresAt.seconds; } if (data.duration) { data.duration = data.duration.seconds; } if (data.reason) { data.reason = getMessageSessionEndReasonString(data.reason); } break; case 'paymentStatus': data.status = getStatusString(data.status, PaymentStatus); break; case 'messageStatus': data.status = getStatusString(data.status, MessageDeliveryStatus); break; case 'receivedMessage': data.sessionId = data.sessionId ? data.sessionId.value : undefined; data.parts = data.partsList.map((part) =&gt; ({ ...part, ussd: part.ussd ? part.ussd.value : undefined, location: part.location ? { ...part.location, label: part.location.label ? part.location.label.value : undefined, address: part.location.address ? part.location.address.value : undefined, } : undefined, media: part.media ? { ...part.media, type: getMediaTypeString(part.media.type), } : undefined, voice: part.voice ? { ...part.voice, dtmfDigits: part.voice.dtmfDigits ? part.voice.dtmfDigits.value : undefined, startedAt: part.voice.startedAt ? part.voice.startedAt.seconds : undefined, recordingUrl: part.voice.recordingUrl ? part.voice.recordingUrl.value : undefined, status: getStatusString(part.voice.status, VoiceCallStatus), direction: getCustomerEventDirectionString(part.voice.direction), hangupCause: getChannelProviderString(part.voice.hangupCause || 0, VoiceCallHangupCause, /^VOICE_CALL_HANGUP_CAUSE_/), } : undefined, })); delete data.partsList; data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; if (data.channelNumber.channel === 'ussd') { data.input = data.parts[0].ussd; delete data.parts; } if (data.channelNumber.channel === 'voice') { data.input = data.parts[0].ussd; data = { ...data, ...data.parts[0].voice, }; delete data.parts; } break; case 'receivedPayment': data.status = getStatusString(data.status, PaymentStatus); data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, PaymentChannel), }; break; case 'walletPaymentStatus': data.status = getStatusString(data.status, PaymentStatus); break; case 'messagingConsentUpdate': data.status = getStatusString(data.status, MessagingConsentUpdateStatus); data.update = getMessageConsentUpdateActionString(data.update); data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; break; case 'customerActivity': data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, ActivityChannel), }; break; case 'sentMessageReaction': data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; data.reaction = getMessageReactionString(data.reaction); break; // Simulator case 'sendMessage': case 'makeVoiceCall': data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; break; case 'checkoutPayment': case 'sendChannelPayment': case 'sendCustomerPayment': data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, PaymentChannel), }; break; default: break; } if (data.customerNumber) { data.customerNumber = { number: data.customerNumber.number, provider: getCustomerNumberProviderString(data.customerNumber.provider), }; } /* eslint-enable no-param-reassign */ return data; }; Elarian.prototype.notificationHandler = (client) =&gt; (incomingPayload) =&gt; { let event; const { log } = client.platform; const { isSimulator } = client.options; let response = isSimulator ? new ServerToSimulatorNotificationReply() : new ServerToAppNotificationReply(); const handlePayload = async () =&gt; { let notif = isSimulator ? ServerToSimulatorNotification.deserializeBinary(incomingPayload.data).toObject() : ServerToAppNotification.deserializeBinary(incomingPayload.data).toObject(); if (!isSimulator) { notif = notif.customer || notif.purse; } const events = Object.keys(notif); event = events.find((i) =&gt; !['orgId', 'appId', 'createdAt', 'customerId', 'purseId'].includes(i) &amp;&amp; notif[i]); const data = cleanUpNotificationPayload(event, { ...notif[event] }); const globalListener = client.eventListeners.data; if (globalListener) { await globalListener(event, data); } let channel; let messagingListener; if (event === 'receivedMessage') { // Split messaging into multiple events channel = data.channelNumber.channel; messagingListener = client.eventListeners[event]; switch (channel) { case 'voice': event = 'voiceCall'; break; case 'ussd': event = 'ussdSession'; break; case 'sms': event = 'receivedSms'; break; case 'messenger': event = 'receivedMessenger'; break; case 'telegram': event = 'receivedTelegram'; break; case 'whatsapp': event = 'receivedWhatsapp'; break; case 'email': event = 'receivedEmail'; break; default: break; } } let listener = client.eventListeners[event]; if (!listener &amp;&amp; messagingListener) { listener = messagingListener; } if (listener) { let customer; if (notif.customerId) { customer = new Customer({ client, customerId: !notif.customerNumber ? notif.customerId : undefined, customerNumber: notif.customerNumber ? { number: notif.customerNumber.number, provider: getCustomerNumberProviderString(notif.customerNumber.provider), } : undefined, }); customer.appData = notif.appData; // customer // .getState() // .catch(log.warn); } // eslint-disable-next-line no-async-promise-executor const listenerExec = new Promise(async (resolve, reject) =&gt; { try { const cb = (error, payload) =&gt; { if (error) { reject(error); } else { resolve(payload); } }; await listener({ data, customer }, cb); } catch (ex) { reject(ex); } }); const payload = await Promise.race([ listenerExec, new Promise((resolve) =&gt; { setTimeout(() =&gt; resolve(false), 15000); }), ]); if (payload) { switch (channel) { case 'voice': // payload is actions[] response = addMessage(new ServerToAppNotificationReply(), { body: { voice: payload, }, }); break; case 'ussd': // payload is { text, isTerminal } response = addMessage(new ServerToAppNotificationReply(), { body: { ussd: payload, }, }); break; default: response = addMessage(new ServerToAppNotificationReply(), payload); break; } } } return response; }; return new Single((subscriber) =&gt; { subscriber.onSubscribe(); handlePayload() .then((data) =&gt; { try { subscriber.onComplete(Buffer.from(data.serializeBinary())); } catch (error) { log.error(`NotificationError::${event}: `, error.message || error); } }) .catch((error) =&gt; { // FIXME: This returns a valid response to avoid retries... // ideally subscriber.onError(error) should be the response try { log.error(`NotificationError::${event}: `, error.message || error); subscriber.onComplete(Buffer.from(response.serializeBinary())); } catch (ex) { log.error(`NotificationError::${event}: `, ex.message || ex); } }); }); }; /** * Register a listener to watch out for events. Can also be called with &lt;code&gt;client.on(event,listener)&lt;/code&gt; * @param {Event} event The event whose listener to register * @param {EventListener} listener A function that reacts to events * @memberof Elarian */ Elarian.prototype.registerListerner = function registerListerner(event, listener) { const events = Object.keys(this.eventListeners); if (!events.includes(event)) { throw new Error(`Unexpected event ${event}`); } this.eventListeners[event] = listener; }; /** * Register a listener to watch out for events. Can also be called with &lt;code&gt;client.registerListerner(event,listener)&lt;/code&gt; * @param {Event} event The event whose listener to register * @param {EventListener} listener A function that reacts to events * @memberof Elarian */ Elarian.prototype.on = function on(event, listerner) { return this.registerListerner(event, listerner); }; /** * Remove listener registered for event. Can also be called with &lt;code&gt;client.off(event)&lt;/code&gt; * @param {Event} event The event whose listener to remove * @memberof Elarian */ Elarian.prototype.removeListener = function removeListener(event) { delete this.eventListeners[event]; }; /** * Remove listener registered for event. Can also be called with &lt;code&gt;client.removeListener(event)&lt;/code&gt; * @param {Event} event The event whose listener to remove * @memberof Elarian */ Elarian.prototype.off = function off(event) { return this.removeListener(event); }; module.exports = Elarian; × Search results Close "},"messaging.js.html":{"id":"messaging.js.html","title":"Source: messaging.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: messaging.js const { ElarianMessages, addTag, addMessage, addCustomer, getStatusString, addCustomerNumber, getMessageConsentUpdateAction, getChannelProvider, } = require('./utils'); const Elarian = require('./client'); const Customer = require('./customer'); const { MessagingChannel, AppToServerCommand, SendMessageCommand, ReplyToMessageCommand, SendMessageTagCommand, MessageDeliveryStatus, MessagingChannelNumber, AppToServerCommandReply, MessagingConsentUpdateStatus, UpdateMessagingConsentCommand, } = ElarianMessages; /** * Send a message * @param {Customer} customer * @param {MessagingChannelNumber} channelNumber * @param {Message} message * @returns {MessageStatus} * @memberof Elarian */ Elarian.prototype.sendMessage = function sendMessage(customer, channelNumber, message) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!customer.customerNumber) { throw new Error('sendMessage() requires a customer with customerNumber'); } let cmd = new SendMessageCommand() .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, MessagingChannel)), ); cmd = addCustomer(cmd, customer); cmd = addMessage(cmd, message); const req = new AppToServerCommand() .setSendMessage(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getSendMessage(); const result = { status: getStatusString(res.getStatus(), MessageDeliveryStatus), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), messageId: (res.getMessageId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Send message by tag * @param {Tag} tag * @param {MessagingChannelNumber} channelNumber * @param {Message} body * @memberof Elarian * @returns {WorkStatus} */ Elarian.prototype.sendMessageByTag = function sendMessageByTag(tag, channelNumber, message) { const socket = this.getSocket(); let cmd = new SendMessageTagCommand() .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, MessagingChannel)), ); cmd = addTag(cmd, tag); cmd = addMessage(cmd, message); const req = new AppToServerCommand() .setSendMessageTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getTagCommand(); const result = { status: res.getStatus(), description: res.getDescription(), workId: (res.getWorkId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Reply to a received message * @param {Customer} customer * @param {string} replyToMessageId * @param {Message} body * @returns {MessageStatus} * @memberof Elarian */ // eslint-disable-next-line max-len Elarian.prototype.replyToMessage = async function replyToMessage(customer, replyToMessageId, message) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } let { customerId } = customer; if (!customerId) { const state = await customer.getState(); customerId = state.customerId; } let cmd = new ReplyToMessageCommand() .setCustomerId(customerId) .setMessageId(replyToMessageId); cmd = addMessage(cmd, message); const req = new AppToServerCommand() .setReplyToMessage(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getSendMessage(); const result = { status: getStatusString(res.getStatus(), MessageDeliveryStatus), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), messageId: (res.getMessageId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Allow or block a customer from receiving messages from a channel * @param {Customer} customer * @param {MessagingChannelNumber} channelNumber * @param {string} action allow or block * @returns {ConsentStatus} * @memberof Elarian */ // eslint-disable-next-line max-len Elarian.prototype.updateMessagingConsent = function updateMessagingConsent(customer, channelNumber, action) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } const { customerNumber } = customer; if (!customerNumber) { // FIXME: Have Elarian return the customer number on fetch state? throw new Error('customerNumber is not setup on this customer'); } let cmd = new UpdateMessagingConsentCommand() .setUpdate(getMessageConsentUpdateAction(action)) .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, MessagingChannel)), ); cmd = addCustomerNumber(cmd, customerNumber); const req = new AppToServerCommand() .setUpdateMessagingConsent(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateMessagingConsent(); const result = { status: getStatusString(res.getStatus(), MessagingConsentUpdateStatus), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"simulator.js.html":{"id":"simulator.js.html","title":"Source: simulator.js","body":" Elarian Classes CustomerElarianSimulator Global Global Source: simulator.js const Elarian = require('./client'); const { getStatus, addCashValue, ElarianMessages, getChannelProvider, getCustomerEventDirection, } = require('./utils'); const { Duration, Timestamp, StringValue, PaymentStatus, PaymentChannel, VoiceCallStatus, MessagingChannel, InboundMessageBody, VoiceCallDialInput, VoiceCallQueueInput, PaymentChannelNumber, VoiceCallHangupCause, MessagingChannelNumber, CustomerEventDirection, SimulatorToServerCommand, VoiceCallInputMessageBody, SimulatorToServerCommandReply, ReceivePaymentSimulatorCommand, ReceiveMessageSimulatorCommand, UpdatePaymentStatusSimulatorCommand, } = ElarianMessages; /** * Instantiate an elarian simulator client * @class * @param {ElarianConfig} config */ function Simulator(config) { Elarian.call(this, { ...config, isSimulator: true }); } Simulator.prototype = Object.create(Elarian.prototype, { constructor: Simulator }); /** * Instantiate and connect an elarian simulator client * @param {ElarianConfig} config */ Simulator.newInstance = async (config) =&gt; { const client = new Simulator(config); await client.connect(); return client; }; /** * Initiate a message request * @param {string} customerNumber * @param {MessagingChannelNumber} channelNumber * @param {string} sessionId * @param {SimulatorMessageBody[]} messageParts * @memberof Simulator */ // eslint-disable-next-line max-len Simulator.prototype.receiveMessage = function receiveMessage(customerNumber, channelNumber, sessionId, messageParts = []) { const socket = this.getSocket(); const parts = messageParts.map((part) =&gt; { let voiceObj; if (part.voice) { let dialObj; if (part.voice.dialData) { const { dialData } = part.voice; dialObj = new VoiceCallDialInput() .setDestinationNumber(dialData.destinationNumber) .setStartedAt(new Timestamp().setSeconds(Math.floor(dialData.startedAt))) .setDuration(new Duration().setSeconds(Math.floor(dialData.duration))); } let queueObj; if (part.queueData) { const { queueData } = part.voice; queueObj = new VoiceCallQueueInput() .setEnqueuedAt(new Timestamp().setSeconds(Math.floor(queueData.enqueuedAt))) .setDequeuedAt(new Timestamp().setSeconds(Math.floor(queueData.dequeuedAt))) .setDequeuedToNumber(new StringValue().setValue(queueData.dequeuedToNumber)) // eslint-disable-next-line max-len .setDequeuedToSessionId(new StringValue().setValue(queueData.dequeuedToSessionId)) .setQueueDuration(new Duration().setSeconds(Math.floor(queueData.duration))); } voiceObj = new VoiceCallInputMessageBody() // eslint-disable-next-line max-len .setDirection(getCustomerEventDirection(part.voice.direction, CustomerEventDirection)) // eslint-disable-next-line max-len .setStartedAt(new Timestamp().setSeconds(Math.floor(part.voice.startedAt || (Date.now() / 1000)))) .setDialData(dialObj) .setQueueData(queueObj); if (part.voice.status) { voiceObj = voiceObj.setStatus(getStatus(part.voice.status, VoiceCallStatus)); } if (part.voice.hangupCause) { voiceObj = voiceObj.setHangupCause(getChannelProvider(part.voice.hangupCause, VoiceCallHangupCause, /^VOICE_CALL_HANGUP_CAUSE_/)); } if (part.voice.dtmfDigits) { // eslint-disable-next-line max-len voiceObj = voiceObj.setDtmlDigits(new StringValue().setValue(part.voice.dtmfDigits)); } if (part.voice.recordingUrl) { // eslint-disable-next-line max-len voiceObj = voiceObj.setRecordingUrl(new StringValue().setValue(part.voice.recordingUrl)); } } const obj = new InboundMessageBody() .setText(part.text) .setMedia(part.media) .setLocation(part.location) .setEmail(part.email) .setUssd(new StringValue().setValue(part.ussd)) .setVoice(voiceObj); return obj; }); const cmd = new ReceiveMessageSimulatorCommand() .setCustomerNumber(customerNumber) .setSessionId(new StringValue().setValue(sessionId)) .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, MessagingChannel)), ) .setPartsList(parts); const req = new SimulatorToServerCommand() .setReceiveMessage(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = SimulatorToServerCommandReply .deserializeBinary(value.data); const result = { status: res.getStatus(), description: res.getDescription(), message: (res.getMessage() || { toObject: () =&gt; {} }).toObject(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Initiate payment request * @param {string} transactionId * @param {string} customerNumber * @param {PaymentChannelNumber} channelNumber * @param {Cash} value * @param {string} status * @memberof Simulator */ // eslint-disable-next-line max-len Simulator.prototype.receivePayment = function receivePayment(transactionId, customerNumber, channelNumber, value, status) { const socket = this.getSocket(); let cmd = new ReceivePaymentSimulatorCommand() .setCustomerNumber(customerNumber) .setTransactionId(transactionId) .setStatus(getStatus(status, PaymentStatus)) .setChannelNumber( new PaymentChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, PaymentChannel)), ); cmd = addCashValue(cmd, value); const req = new SimulatorToServerCommand() .setReceivePayment(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: ({ data }) =&gt; { try { const res = SimulatorToServerCommandReply .deserializeBinary(data); const result = { status: res.getStatus(), description: res.getDescription(), message: (res.getMessage() || { toObject: () =&gt; {} }).toObject(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Update payment status * @param {string} transactionId * @param {string} status * @memberof Simulator */ Simulator.prototype.updatePaymentStatus = function updatePaymentStatus(transactionId, status) { const socket = this.getSocket(); const cmd = new UpdatePaymentStatusSimulatorCommand() .setTransactionId(transactionId) .setStatus(getStatus(status, PaymentStatus)); const req = new SimulatorToServerCommand() .setUpdatePaymentStatus(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = SimulatorToServerCommandReply .deserializeBinary(value.data); const result = { status: res.getStatus(), description: res.getDescription(), message: (res.getMessage() || { toObject: () =&gt; {} }).toObject(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Simulator; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Elarian Classes CustomerElarianSimulator Global Global Global Type Definitions Activity An object representing a customer activity Type: Object Properties: Name Type Argument Description sessionId string key string properties Object &lt;optional&gt; Source: utils/doc.js, line 146 ActivityChannelNumber An object representing an activity channel number Type: Object Properties: Name Type Description number string channel string channel type. Must be one of ['web','modile'] Source: utils/doc.js, line 209 AuthToken Type: Object Properties: Name Type Description token string lifetime number in seconds Source: utils/doc.js, line 461 Body An object representing a message body Type: Object Properties: Name Type Argument Description text string &lt;optional&gt; template Template &lt;optional&gt; media Media &lt;optional&gt; location Location &lt;optional&gt; email Email &lt;optional&gt; url string &lt;optional&gt; ussd UssdMenu &lt;optional&gt; voice Array.&lt;VoiceAction&gt; &lt;optional&gt; Source: utils/doc.js, line 59 Cash An object representing cash Type: Object Properties: Name Type Description amount double currencyCode string Source: utils/doc.js, line 182 ConfigOptions An object representing config options Type: Object Properties: Name Type Argument Description lifetime number &lt;optional&gt; keepAlive number &lt;optional&gt; serializer Serializer &lt;optional&gt; used to (de)serialize your metadata Source: utils/doc.js, line 174 ConsentStatus Type: Object Properties: Name Type Description status string description string customerId string Source: utils/doc.js, line 448 CustomerNumber An object representing a customer number. Type: Object Properties: Name Type Argument Description number string provider cellular | telegram | facebook | email | web partition string &lt;optional&gt; Source: utils/doc.js, line 17 CustomerParams An object representing customer params Type: Object Properties: Name Type Description client Elarain customerNumber CustomerNumber Source: utils/doc.js, line 250 CustomerPayment An object representing a customer's payment source or destination Type: Object Properties: Name Type Description customerNumber CustomerNumber channelNumber PaymentChannelNumber Source: utils/doc.js, line 243 Dequeue An object representing a 'dequeue' voice action Type: Object Source: utils/doc.js, line 331 Dial An object representing a 'dial' voice action Type: Object Properties: Name Type Description customerNumbers Array.&lt;CustomerNumber&gt; record boolean sequential boolean ringbackTone string callerId string maxDuration number Source: utils/doc.js, line 297 ElarianConfig An object representing client params Type: Object Properties: Name Type Argument Description apiKey string appId string orgId string authToken string &lt;optional&gt; received from an client that authenticated with the API key. @see Elarian.generateAuthToken() isSimulator boolean &lt;optional&gt; Run this client as a simulator allowNotifications boolean &lt;optional&gt; allow this non-simulator client to receive notifications or not options ConfigOptions &lt;optional&gt; setup connection options Source: utils/doc.js, line 154 Email An object representing email Type: Object Properties: Name Type Description subject string bodyPlain string bodyHtml string ccList Array.&lt;string&gt; bccList Array.&lt;string&gt; attachments Array.&lt;string&gt; Source: utils/doc.js, line 48 Enqueue An object representing a 'enqueue' voice action Type: Object Source: utils/doc.js, line 324 Event An string representing an event. Must be one of: data -- voiceCall ussdSession receivedSms receivedEmail receivedMessenger receivedTelegram receivedWhatsapp -- sendMessage makeVoiceCall sendCustomerPayment sendChannelPayment checkoutPayment -- reminder messageStatus paymentStatus receivedPayment receivedMessage customerActivity walletPaymentStatus sentMessageReaction messagingSessionEnded messagingConsentUpdate messagingSessionStarted messagingSessionRenewed Type: string Source: utils/doc.js, line 388 EventListener(notification, callback) A function that reacts to events Parameters: Name Type Description notification Notification callback NotificationCallback A response to the event. Required for voice and ussd events Source: utils/doc.js, line 380 Returns: Type void GetDigits An object representing a 'getDigits' voice action Type: Object Properties: Name Type Argument Description timeout number finishOnKey string numDigits number say Say &lt;optional&gt; play Play &lt;optional&gt; Source: utils/doc.js, line 287 GetRecording An object representing a 'getRecording' voice action Type: Object Properties: Name Type Argument Description playBeep boolean trimSilence boolean timeout number maxLength number finishOnKey string say Say &lt;optional&gt; play Play &lt;optional&gt; Source: utils/doc.js, line 339 LeasedAppData Type: string | * Source: utils/doc.js, line 456 Location An object representing location Type: Object Properties: Name Type Description latitude double longitude double label string address string Source: utils/doc.js, line 39 Media An object representing media Type: Object Properties: Name Type Description url string type image | video | audio | document | voice | sticker | contact Source: utils/doc.js, line 32 Message An object representing a message body Type: Object Properties: Name Type Argument Description body Body labels Array.&lt;string&gt; &lt;optional&gt; providerTag string &lt;optional&gt; replyToken string &lt;optional&gt; replyPrompt ReplyPrompt &lt;optional&gt; Source: utils/doc.js, line 136 MessageStatus Type: Object Properties: Name Type Description status string description string customerId string messageId string Source: utils/doc.js, line 439 MessagingChannelNumber An object representing a messaging channel number Type: Object Properties: Name Type Description number string channel sms | telegram | whatsapp | email | messenger | voice Source: utils/doc.js, line 25 Notification Notification data Type: Object Properties: Name Type Description data Object customer Customer Source: utils/doc.js, line 365 NotificationCallback(error [, message]) Notification callback Parameters: Name Type Argument Description error Error message Message | UssdMenu | Array.&lt;VoiceAction&gt; &lt;optional&gt; Source: utils/doc.js, line 372 Returns: Type void PaymentChannelNumber An object representing a payment channel Type: Object Properties: Name Type Description number string channel string number provider. Must be one of ['cellular'] Source: utils/doc.js, line 202 PaymentStatus Type: Object Properties: Name Type Description status number description string transactionId string debitCustomerId string creditCustomerId string Source: utils/doc.js, line 468 PaymentTransaction An object representing a payment transaction Type: Object Properties: Name Type Description transactionId string appId string creditParty CustomerPayment | Wallet | Purse debitParty CustomerPayment | Wallet | Purse value Cash status number createdAt number updatedAt number Source: utils/doc.js, line 216 Play An object representing a 'play' voice action Type: Object Properties: Name Type Description url string Source: utils/doc.js, line 281 PromptMenuItem An object representing a message reply prompt Type: Object Properties: Name Type Argument Description text string &lt;optional&gt; media Media &lt;optional&gt; Source: utils/doc.js, line 115 Purse An object representing purse Type: Object Properties: Name Type Description purseId string Source: utils/doc.js, line 196 RecordSession An object representing a 'recordSession' voice action Type: boolean Source: utils/doc.js, line 308 Redirect An object representing a 'redirect' voice action Type: Object Source: utils/doc.js, line 318 Reject An object representing a 'reject' voice action Type: boolean Source: utils/doc.js, line 313 Reminder An object representing a reminder Type: Object Properties: Name Type Argument Description key string remindAt number timestamp in seconds payload string interval number &lt;optional&gt; Source: utils/doc.js, line 257 ReplyPrompt An object representing a message reply prompt Type: Object Properties: Name Type Description action string text, phone_number, email, location, url menu Array.&lt;PromptMenuItem&gt; Source: utils/doc.js, line 129 Say An object representing a 'say' voice action Type: Object Properties: Name Type Argument Description text string playBeep boolean &lt;optional&gt; voice male | female &lt;optional&gt; Source: utils/doc.js, line 273 SecondaryId An object representing a secondary id. Secondary Ids can be used to add some more unique identities to a customer. e.g. driver's license, etc. Type: Object Properties: Name Type Description key string value string Source: utils/doc.js, line 10 Serializer An object representing serializer Type: Object Properties: Name Type Description type text | binary serialize function deserialize function Source: utils/doc.js, line 166 SimulatorMessageBody An object representing a message body Type: Object Properties: Name Type Argument Description text string &lt;optional&gt; media Media &lt;optional&gt; location Location &lt;optional&gt; email Email &lt;optional&gt; ussd string &lt;optional&gt; voice VoiceCallInput &lt;optional&gt; Source: utils/doc.js, line 72 Tag An object representing a tag. Tags can be used to group customers based on some similarities. e.g. loan defaulters, etc. Type: Object Properties: Name Type Argument Description key string value string expiresAt number &lt;optional&gt; Source: utils/doc.js, line 2 Template An object representing a text template Type: Object Properties: Name Type Description id string params Object Source: utils/doc.js, line 122 UpdateStatus Type: Object Properties: Name Type Description customerId string status boolean description string Source: utils/doc.js, line 423 UssdChannelNumber An object representing a ussd channel Type: Object Properties: Name Type Description number string channel string Source: utils/doc.js, line 236 UssdMenu An object representing a ussd menu Type: Object Properties: Name Type Description text string isTerminal boolean Source: utils/doc.js, line 266 VoiceAction An object representing a voice action. Note: Only one action is required in the object. Type: Object Properties: Name Type Description say Say play Play dial Dial recordSession RecordSession getRecording GetRecording enqueue Enqueue dequeue Dequeue reject Reject redirect Redirect Source: utils/doc.js, line 351 VoiceCallDialInput An object representing a voice call dial input Type: Object Properties: Name Type Description destinationNumber string startedAt number duration number Source: utils/doc.js, line 96 VoiceCallInput An object representing a voice call input Type: Object Properties: Name Type Description direction string outbound or inbound status string startedAt number hangupCause string dtmfDigits string recordingUrl string dialData VoiceCallDialInput queueData VoiceCallQueueInput Source: utils/doc.js, line 83 VoiceCallQueueInput An object representing a voice call queue input Type: Object Properties: Name Type Description destinationNumber string enqueuedAt number dequeuedAt number dequeuedToNumber string dequeuedToSessionId string queueDuration number Source: utils/doc.js, line 104 VoiceChannelNumber An object representing a voice channel Type: Object Properties: Name Type Description number string channel string Source: utils/doc.js, line 229 VoiceStatus Type: Object Properties: Name Type Description status number description string sessionId string customerId string Source: utils/doc.js, line 478 Wallet An object representing wallet Type: Object Properties: Name Type Description customerId string walletId string Source: utils/doc.js, line 189 WorkStatus Type: Object Properties: Name Type Description status boolean description string workId string Source: utils/doc.js, line 431 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Elarian Classes CustomerElarianSimulator Global Global Classes Classes Customer Elarian Simulator × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Elarian Classes CustomerElarianSimulator Global Global Elarian A convenient way to interact with the Elarian APIs. Install You can install the package from npm by running: $ npm install elarian Usage // on node const { Elarian } = require('elarian'); /* or in the browser &lt;script src=\"dist/elarian.min.js\"&gt;&lt;/script&gt; const { Elarian } = ElarianSDK; */ // ... const client = await Elarian.newInstance({ apiKey: 'YOUR_API_KEY', // or authToken: 'YOUR_AUTH_TOKEN' orgId: 'YOUR_ORG_ID', appId: 'YOUR_APP_ID', }); client.on('ussdSession', async ({ data, customer}, callback) =&gt; { const { input, sessionId, } = data; const appData = await customer.leaseAppData(); let { name, state = 'newbie', } = appData; const menu = { text: null, isTerminal: true, }; switch (state) { case 'veteran': if (name) { menu.text = `Welcome back ${name}! What is your new name?`; menu.isTerminal = false; } else { name = input.value; menu.text = `Thank you for trying Elarian, ${name}!`; menu.isTerminal = true; await customer.sendMessage( { number: 'Elarian', provider: 'telco' }, { text: `Hey ${name}! Thank you for trying out Elarian` }, ); } break; case 'newbie': default: menu.text = 'Hey there, welcome to Elarian! What\\'s your name?'; menu.isTerminal = false; state = 'veteran'; break; } await customer.updateAppData({ state, name }); callback(null, menu); }); Documentation Take a look at the API docs here. For detailed info on this SDK, see the documentation. Development Run all tests: $ npm install $ npm test Issues If you find a bug, please file an issue on our issue tracker on GitHub. × Search results Close "},"Customer.html":{"id":"Customer.html","title":"Class: Customer","body":" Elarian Classes CustomerElarianSimulator Global Global Class: Customer Customer new Customer(params) A customer is your end-user, represented by a number (from a cellular, facebook or telegram) Parameters: Name Type Description params CustomerParams Source: customer.js, line 15 Methods addReminder(reminder) Set a reminder to be triggered at the specified time for a particular customer Parameters: Name Type Description reminder Reminder Source: customer.js, line 123 Returns: Type UpdateStatus adoptState(otherCustomer) Merge otherCustomer's state into this customer's state and discard otherCustomer Parameters: Name Type Description otherCustomer Customer Source: customer.js, line 86 Returns: Type UpdateStatus cancelReminder(key) Cancels a previously set reminder with the key key on the customer Parameters: Name Type Description key string Source: customer.js, line 130 Returns: Type UpdateStatus deleteAppData() Remove customer's app data Source: customer.js, line 168 Returns: Type UpdateStatus deleteMetadata(keys) Remove some metadata from a customer. keys is an array of strings Parameters: Name Type Description keys Array.&lt;string&gt; Source: customer.js, line 146 Returns: Type UpdateStatus deleteSecondaryId(secondaryIds) Remove some secondary Ids from a customer Parameters: Name Type Description secondaryIds Array.&lt;SecondaryId&gt; Source: customer.js, line 116 Returns: Type UpdateStatus deleteTag(tags) Remove some tags from a customer Parameters: Name Type Description tags Array.&lt;Tag&gt; Source: customer.js, line 100 Returns: Type UpdateStatus getState() Fetch the customer's current state. Source: customer.js, line 59 Returns: Type CustomerState leaseAppData() Fetches the customer's app data and lock it from fetching(for up to 90s) until next call to update app data. Source: customer.js, line 162 Returns: Type LeasedAppData makeVoiceCall(channelNumber, actions) Initiate a voice call to the customer Parameters: Name Type Description channelNumber string actions Array.&lt;VoiceAction&gt; Source: customer.js, line 186 Returns: Type MessageStatus requestPayment(source, destination, value) Initiate a payment transaction Parameters: Name Type Description source PaymentChannelNumber | Wallet destination Wallet | Purse value Cash Source: customer.js, line 214 Returns: Type PaymentStatus sendMessage(channelNumber, body) Send a message to the customer from the specified channel number. Parameters: Name Type Description channelNumber MessagingChannelNumber body Body Source: customer.js, line 177 Returns: Type MessageStatus updateActivity(channelNumber, sessionId) Initiate a customer activity Parameters: Name Type Description channelNumber ActivityChannelNumber sessionId Activity Source: customer.js, line 204 Returns: Type UpdateStatus updateAppData(data) Sets some app data on the customer. Values in the data object can either be strings or buffers, depending on the set serializer Parameters: Name Type Description data Object Source: customer.js, line 155 Returns: Type UpdateStatus updateMessagingConsent(channelNumber, action) Allow or block a customer from receiving messages from a channel Parameters: Name Type Description channelNumber MessagingChannelNumber action string allow or block Source: customer.js, line 195 Returns: Type ConsentStatus updateMetadata(metadata) Sets some metadata on the customer. Values in the metadata object can either be strings or buffers, depending on the set serializer Parameters: Name Type Description metadata Object Source: customer.js, line 139 Returns: Type UpdateStatus updateSecondaryId(secondaryIds) Update a customer's secondary Ids Parameters: Name Type Description secondaryIds Array.&lt;SecondaryId&gt; Source: customer.js, line 108 Returns: Type UpdateStatus updateTag(tags) Update a customer's tag list. Parameters: Name Type Description tags Array.&lt;Tag&gt; Source: customer.js, line 93 Returns: Type UpdateStatus × Search results Close "},"Elarian.html":{"id":"Elarian.html","title":"Class: Elarian","body":" Elarian Classes CustomerElarianSimulator Global Global Class: Elarian Elarian new Elarian(config) Instantiate an elarian client. You have to call connect() on then client to start using it Parameters: Name Type Description config ElarianConfig Source: client.js, line 28 Methods &lt;static&gt; newInstance(config) Instantiate and connect an elarian client Parameters: Name Type Description config ElarianConfig Source: client.js, line 161 addCustomerReminder(customer, reminder) Set a reminder to be triggered at the specified time for a particular customer Parameters: Name Type Description customer Customer reminder Reminder Source: state.js, line 473 Returns: Type UpdateStatus addCustomerReminderByTag(tag, reminder) Set a reminder to be triggered at the specified time for customers with the particular tag Parameters: Name Type Description tag Tag reminder Reminder Source: state.js, line 585 Returns: Type WorkStatus adoptCustomerState(customer, otherCustomer) Adopt another customer's state Parameters: Name Type Description customer Customer otherCustomer Customer Source: state.js, line 188 Returns: Type UpdateStatus cancelCustomerReminder(customer, key) Cancels a previously set reminder with the key key on the customer Parameters: Name Type Description customer Customer key string Source: state.js, line 529 Returns: Type UpdateStatus cancelCustomerReminderByTag(tag, key) Cancels a previously set reminder with tag tag and key key Parameters: Name Type Description tag Tag key string Source: state.js, line 633 Returns: Type WorkStatus connect() Connect to the elarian server Source: client.js, line 110 deleteCustomerAppData(customer) Remove customer's app data. Parameters: Name Type Description customer Customer Source: state.js, line 928 Returns: Type UpdateStatus deleteCustomerMetadata(customer, keys) Remove some metadata from a customer. Parameters: Name Type Description customer Customer keys Array.&lt;string&gt; Source: state.js, line 751 Returns: Type UpdateStatus deleteCustomerSecondaryId(customer, secondaryIds) Delete a customer's secondary Ids Parameters: Name Type Description customer Customer secondaryIds Array.&lt;SecondaryId&gt; Source: state.js, line 417 Returns: Type UpdateStatus deleteCustomerTag(customer, tags) Remove tags from a customer Parameters: Name Type Description customer Customer tags Array.&lt;string&gt; Source: state.js, line 303 Returns: Type UpdateStatus disconnect() Disconnect from the elarian server Source: client.js, line 134 generateAuthToken() Generate a short-lived auth token to use instead of apiKey. Used for browser and mobile clients. Source: authentication.js, line 16 Returns: Type AuthToken getCustomerState(customer) Fetch the customer's current state. Parameters: Name Type Description customer Customer Source: state.js, line 53 Returns: Type CustomerState initiatePayment(debitParty, creditParty, value) Initiate a payment transaction Parameters: Name Type Description debitParty CustomerPayment | Wallet | Purse creditParty CustomerPayment | Wallet | Purse value Cash Source: payment.js, line 25 Returns: Type PaymentStatus leaseCustomerAppData(customer) Fetches the customer's app data and lock it from fetching(for up to 90s) until next call to update app data. Parameters: Name Type Description customer Customer Source: state.js, line 871 Returns: Type LeasedAppData makeVoiceCall(customer, channelNumber, actions) Initiate a voice call to customer from channelNumber Parameters: Name Type Description customer Customer channelNumber string actions Array.&lt;VoiceAction&gt; Source: voice.js, line 30 Returns: Type VoiceStatus off(event) Remove listener registered for event. Can also be called with client.removeListener(event) Parameters: Name Type Description event Event The event whose listener to remove Source: notification.js, line 357 on(event, listener) Register a listener to watch out for events. Can also be called with client.registerListerner(event,listener) Parameters: Name Type Description event Event The event whose listener to register listener EventListener A function that reacts to events Source: notification.js, line 341 registerListerner(event, listener) Register a listener to watch out for events. Can also be called with client.on(event,listener) Parameters: Name Type Description event Event The event whose listener to register listener EventListener A function that reacts to events Source: notification.js, line 327 removeListener(event) Remove listener registered for event. Can also be called with client.off(event) Parameters: Name Type Description event Event The event whose listener to remove Source: notification.js, line 348 replyToMessage(customer, replyToMessageId, body) Reply to a received message Parameters: Name Type Description customer Customer replyToMessageId string body Message Source: messaging.js, line 148 Returns: Type MessageStatus sendMessage(customer, channelNumber, message) Send a message Parameters: Name Type Description customer Customer channelNumber MessagingChannelNumber message Message Source: messaging.js, line 36 Returns: Type MessageStatus sendMessageByTag(tag, channelNumber, body) Send message by tag Parameters: Name Type Description tag Tag channelNumber MessagingChannelNumber body Message Source: messaging.js, line 97 Returns: Type WorkStatus updateCustomerActivity(customerNumber, channelNumber, activity) Initiate a customer activity Parameters: Name Type Description customerNumber CustomerNumber channelNumber ActivityChannelNumber activity Activity Source: state.js, line 977 Returns: Type UpdateStatus updateCustomerAppData(customer, data) Sets some app data on the customer. Value of the data object can either be a string or a buffer, depending on your serializer. @see Client Parameters: Name Type Description customer Customer data Object Source: state.js, line 805 Returns: Type UpdateStatus updateCustomerMetadata(customer, metadata) Sets some metadata on the customer. Values in the metadata object can either be strings or buffers, depending on your serializer. @see Client Parameters: Name Type Description customer Customer metadata Object Source: state.js, line 683 Returns: Type UpdateStatus updateCustomerSecondaryId(customer, secondaryIds) Update a customer's secondary Ids Parameters: Name Type Description customer Customer secondaryIds Array.&lt;SecondaryId&gt; Source: state.js, line 360 Returns: Type UpdateStatus updateCustomerTag(customer, tags) Update a customer's tag list Parameters: Name Type Description customer Customer tags Array.&lt;Tag&gt; Source: state.js, line 247 Returns: Type UpdateStatus updateMessagingConsent(customer, channelNumber, action) Allow or block a customer from receiving messages from a channel Parameters: Name Type Description customer Customer channelNumber MessagingChannelNumber action string allow or block Source: messaging.js, line 209 Returns: Type ConsentStatus × Search results Close "},"Simulator.html":{"id":"Simulator.html","title":"Class: Simulator","body":" Elarian Classes CustomerElarianSimulator Global Global Class: Simulator Simulator new Simulator(config) Instantiate an elarian simulator client Parameters: Name Type Description config ElarianConfig Source: simulator.js, line 39 Methods &lt;static&gt; newInstance(config) Instantiate and connect an elarian simulator client Parameters: Name Type Description config ElarianConfig Source: simulator.js, line 49 receiveMessage(customerNumber, channelNumber, sessionId, messageParts) Initiate a message request Parameters: Name Type Description customerNumber string channelNumber MessagingChannelNumber sessionId string messageParts Array.&lt;SimulatorMessageBody&gt; Source: simulator.js, line 64 receivePayment(transactionId, customerNumber, channelNumber, value, status) Initiate payment request Parameters: Name Type Description transactionId string customerNumber string channelNumber PaymentChannelNumber value Cash status string Source: simulator.js, line 175 updatePaymentStatus(transactionId, status) Update payment status Parameters: Name Type Description transactionId string status string Source: simulator.js, line 224 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
