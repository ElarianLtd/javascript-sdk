<html>
<head>
</head>
<body style="background: transparent;">
    <script src="scripts/docstrap.lib.js"></script>
    <script src="scripts/lunr.min.js"></script>
    <script src="scripts/fulltext-search.js"></script>

    <script type="text/x-docstrap-searchdb">
    {"utils_types.js.html":{"id":"utils_types.js.html","title":"Source: utils/types.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: utils/types.js /* eslint-disable max-len */ /** * An object representing client params * @typedef {Object} ClientConfig * @property {string} apiKey * @property {string} appId * @property {string} orgId * @property {string} [authToken] received from an client that authenticated with the API key. @see {@link Elarian.generateAuthToken} * @property {boolean} [isSimulator] Run this client as a simulator * @property {boolean} [allowNotifications] allow this non-simulator client to receive notifications or not * @property {ConnectionOptions} [options] setup connection options */ /** * An object representing serializer * @typedef {Object} Serializer * @property {text|binary} type * @property {function} serialize * @property {function} deserialize */ /** * An object representing config options * @typedef {Object} ConnectionOptions * @property {number} [lifetime = 6000] * @property {number} [keepAlive = 1000] * @property {boolean} [resumable = false] * @property {number} [notificationTimeout = 5000] * @property {number} [reconnectTimeout = 60000] * @property {Serializer} [serializer] used to (de)serialize your metadata */ /** * An object representing customer params * @typedef {Object} CustomerParams * @property {string} customerId * @property {string} number * @property {string} [provider=cellular] * @property {string} [partition] */ /** * An object representing a tag. Tags can be used to group customers based on some similarities. e.g. loan defaulters, etc. * @typedef {Object} Tag * @property {string} key * @property {string} value * @property {number} [expiresAt] timestamp in seconds. e.g. 1615361861 */ /** * An object representing a reminder * @typedef {Object} Reminder * @property {string} key * @property {number} remindAt timestamp in seconds e.g 1615361861 * @property {string} payload * @property {number} [interval] duration in seconds e.g. 60 */ /** * An object representing auth token * @typedef {Object} AuthToken * @property {string} token * @property {number} lifetime in seconds */ /** * An obkect representing a paymennt reply * @typedef {Object} InitiatePaymentReply * @property {number} status * @property {string} description * @property {string} transactionId * @property {string} debitCustomerId * @property {string} creditCustomerId */ /** * * @typedef {Object} TagUpdateReply * @property {boolean} status * @property {string} description * @property {string} workId */ /** * An object representing a message * @typedef {Object} Message * @property {MessageBody} body * @property {string[]} [labels] * @property {string} [providerTag] * @property {string} [replyToken] * @property {ReplyPrompt} [replyPrompt] */ /** * An object representing a message body * @typedef {Object} MessageBody * @property {string} [text] * @property {Template} [template] * @property {Media} [media] * @property {Location} [location] * @property {Email} [email] * @property {string} [url] * @property {UssdMenu} [ussd] * @property {VoiceAction[]} [voice] */ /** * An object representing a ussd menu * @typedef {Object} UssdMenu * @property {string} text * @property {boolean} isTerminal */ /** * An object representing a message reply prompt * @typedef {Object} PromptMenuItem * @property {string} [text] * @property {Media} [media] */ /** * An object representing a text template * @typedef {Object} Template * @property {string} id * @property {Object} params */ /** * An object representing a message reply prompt * @typedef {Object} ReplyPrompt * @property {string} action text, phone_number, email, location, url * @property {PromptMenuItem[]} menu */ /** * An object representing a secondary id. Secondary Ids can be used to add some more unique identities to a customer. e.g. driver's license, etc. * @typedef {Object} SecondaryId * @property {string} key * @property {string} value */ /** * An object representing a customer number. * @typedef {Object} CustomerNumber * @property {string} number * @property {string} provider one of [cellular|telegram|facebook|email|app] * @property {string} [partition] */ /** * An object representing media * @typedef {Object} Media * @property {string} url * @property {string} type one of [image|video|audio|document|voice|sticker|contact] */ /** * An object representing location * @typedef {Object} Location * @property {double} latitude * @property {double} longitude * @property {string} label * @property {string} address */ /** * An object representing email * @typedef {Object} Email * @property {string} subject * @property {string} bodyPlain * @property {string} bodyHtml * @property {string[]} ccList * @property {string[]} bccList */ /** * An object representing cash * @typedef {Object} Cash * @property {number} amount * @property {string} currencyCode */ /** * An object representing a 'say' voice action * @typedef {Object} Say * @property {string} text * @property {boolean} [playBeep] * @property {male|female} [voice] */ /** * An object representing a 'play' voice action * @typedef {Object} Play * @property {string} url */ /** * An object representing a 'getDigits' voice action * @typedef {Object} GetDigits * @property {number} timeout * @property {string} finishOnKey * @property {number} numDigits * @property {Say} [say] * @property {Play} [play] */ /** * An object representing a 'dial' voice action * @typedef {Object} Dial * @property {CustomerNumber[]} customerNumbers * @property {boolean} record * @property {boolean} sequential * @property {string} ringbackTone * @property {string} callerId * @property {number} maxDuration */ /** * An object representing a 'recordSession' voice action * @typedef {Object} RecordSession */ /** * An object representing a 'reject' voice action * @typedef {Object} Reject */ /** * An object representing a 'redirect' voice action * @typedef {Object} Redirect * @property {string} url */ /** * An object representing a 'enqueue' voice action * @typedef {Object} Enqueue * @param {string} queueName * @param {string} holdMusic */ /** * An object representing a 'dequeue' voice action * @typedef {Object} Dequeue * @param {string} queueName * @param {boolean} record * @param {ChannelNumber} channelNumber */ /** * An object representing a 'getRecording' voice action * @typedef {Object} GetRecording * @property {boolean} playBeep * @property {boolean} trimSilence * @property {number} timeout * @property {number} maxLength * @property {string} finishOnKey * @property {Say} [say] * @property {Play} [play] */ /** * An object representing a voice action. Note: Only one action is required in the object. * @typedef {Object} VoiceAction * @property {Say} say * @property {Play} play * @property {Dial} dial * @property {RecordSession} recordSession * @property {GetRecording} getRecording * @property {Enqueue} enqueue * @property {Dequeue} dequeue * @property {Reject} reject * @property {Redirect} redirect */ /** * An object representing the notification data * @typedef {Object} Notification * @property {string} orgId * @property {string} appId * @property {string} customerId * @property {long} createdAt */ /** * Notification callback * @typedef {function} NotificationCallback * @param {MessageBody} [message = null] * @param {Object} [appData = null] * @returns {void} */ /** * A function that reacts to events * @typedef {function} NotificationHandler * @param {Notification} notification * @param {Customer} customer * @param {NotificationCallback} [callback] A response to the event. Required for voice and ussd events * @returns {void} */ /** * Reminder notification * @typedef {Notification} ReminderNotification * @property {Reminder} reminder * @property {Tag} tag * @property {string} workId */ /** * Voice call notification * @typedef {Notification} VoiceCallNotification * @property {string} messageId * @property {CustomerNumber} customerNumber * @property {MessagingChannelNumber} channel * @property {VoiceCallInput} voice */ /** * Message status notification * @typedef {Notification} MessageStatusNotification * @property {string} messageId * @property {string} status one of [queued, sent, delivered, read, received, session_initiated, failed, no_consent, no_capability, expired, no_session_in_progress, other_session_in_progress, invalid_reply_token, invalid_channel_number, not_supported, invalid_reply_to_message_id, invalid_customer_id, duplicate_request , tag_not_found, customer_number_not_found, decommissioned_customerid, rejected, invalid_request, insufficient_credits, application_error] */ /** * USSD session notification * @typedef {Notification} UssdSessionNotification * @property {string} messageId * @property {string} sessionId * @property {CustomerNumber} customerNumber * @property {MessagingChannelNumber} channel * @property {UssdInput} input */ /** * SMS notification * @typedef {Notification} ReceivedSmsNotification * @property {string} messageId * @property {CustomerNumber} customerNumber * @property {MessagingChannelNumber} channel * @property {string} text */ /** * Whatsapp, telegram or email notification * @typedef {Notification} ReceivedMediaNotification * @property {string} messageId * @property {CustomerNumber} customerNumber * @property {MessagingChannelNumber} channel * @property {string} sessionnId * @property {string} [inReplyTo] * @property {string} [text] * @property {Media} [media] * @property {Location} [location] * @property {Email} [email] */ /** * Payment status notification * @typedef {Notification} PaymentStatusNotification * @property {string} [purseId] * @property {string} transactionId * @property {string} status one of [queued, pending_confirmation, pending_validation, validated, invalid_request, not_supported, insufficient_funds, application_error, not_allowed, duplicate_request, invalid_purse, invalid_wallet, decommissioned_customer_id, success, failed, throttled, expired, rejected, reversed] */ /** * Payment status notification * @typedef {Notification} ReceivedPaymentNotification * @property {string} purseId * @property {string} transactionId * @property {CustomerNumber} customerNumber * @property {PaymentChannelNumber} channelNumber * @property {Cash} value * @property {string} status one of [queued, pending_confirmation, pending_validation, validated, invalid_request, not_supported, insufficient_funds, application_error, not_allowed, duplicate_request, invalid_purse, invalid_wallet, decommissioned_customer_id, success, failed, throttled, expired, rejected, reversed] */ /** * Wallet payment status notification * @typedef {Notification} WalletPaymentStatusNotification * @property {string} walletId * @property {string} transactionId * @property {string} status one of [queued, pending_confirmation, pending_validation, validated, invalid_request, not_supported, insufficient_funds, application_error, not_allowed, duplicate_request, invalid_purse, invalid_wallet, decommissioned_customer_id, success, failed, throttled, expired, rejected, reversed] */ /** * Customer activity notification * @typedef {Notification} CustomerActivityNotification * @property {string} sessionId * @property {CustomerNumber} customerNumber * @property {string} source * @property {Activity} activity */ /** * And object representing a customer activity * @typedef {Object} Activity * @property {string} key * @property {string} sessionId * @property {Object} properties * @property {long} createdAt */ /** * Message reaction notification * @typedef {Notification} SentMessageReactionNotification * @property {string} messageId * @property {CustomerNumber} customerNumber * @property {MessagingChannelNumber} channelNumber * @property {string} reaction one of [clicked, unsubscribed, complained] */ /** * Messaging session ended notification * @typedef {Notification} MessagingSessionEndedNotification * @property {string} sessionId * @property {CustomerNumber} customerNumber * @property {MessagingChannelNumber} channelNumber * @property {number} duration in seconds * @property {string} reason one of [normal_clearing, inactivity, failure] */ /** * Messaging session initialized notification * @typedef {Notification} MessagingSessionInitializedNotification * @property {string} sessionId * @property {CustomerNumber} customerNumber * @property {MessagingChannelNumber} channelNumber * @property {number} expiresAt timestamp in seconds */ /** * Messaging consent update notification * @typedef {Notification} MessagingConsentUpdateNotification * @property {string} sessionId * @property {CustomerNumber} customerNumber * @property {MessagingChannelNumber} channelNumber * @property {string} update one of [allow, block] * @property {string} status one of [queued, completed, invalid_channel_number, decommissioned_customer_id, application_error] */ /** * An string representing an event. Must be one of: * &lt;ul&gt; * &lt;li&gt;Connection Events: * &lt;ul&gt; * &lt;li&gt;&lt;b&gt;error&lt;/b&gt;: Emitted on connection error&lt;/li&gt; * &lt;li&gt;&lt;b&gt;closed&lt;/b&gt;: Emitted on connection closed&lt;/li&gt; * &lt;li&gt;&lt;b&gt;pending&lt;/b&gt;: Emitted when not connected&lt;/li&gt; * &lt;li&gt;&lt;b&gt;connected&lt;/b&gt;: Emitted on connection success&lt;/li&gt; * &lt;li&gt;&lt;b&gt;connecting&lt;/b&gt;: Emitted when connecting &lt;/li&gt; * &lt;/ul&gt; * &lt;/li&gt; * &lt;li&gt;App Events * &lt;ul&gt; * &lt;li&gt;&lt;b&gt;reminder&lt;/b&gt;: @see {@link ReminderNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;voiceCall&lt;/b&gt;: @see {@link VoiceCallNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;messageStatus&lt;/b&gt;: @see {@link MessageStatusNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;ussdSession&lt;/b&gt;: @see {@link UssdSessionNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;receivedSms&lt;/b&gt;: @see {@link ReceivedSmsNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;receivedEmail&lt;/b&gt;: @see {@link ReceivedMediaNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;receivedFbMessenger&lt;/b&gt;: @see {@link ReceivedMediaNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;receivedTelegram&lt;/b&gt;: @see {@link ReceivedMediaNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;receivedWhatsapp&lt;/b&gt;: @see {@link ReceivedMediaNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;paymentStatus&lt;/b&gt;: @see {@link PaymentStatusNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;receivedPayment&lt;/b&gt;: @see {@link ReceivedPaymentNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;customerActivity&lt;/b&gt;: @see {@link CustomerActivityNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;walletPaymentStatus&lt;/b&gt;: @see {@link WalletPaymentStatusNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;sentMessageReaction&lt;/b&gt;: @see {@link SentMessageReactionNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;messagingSessionEnded&lt;/b&gt;: @see {@link MessagingSessionEndedNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;messagingConsentUpdate&lt;/b&gt;: @see {@link MessagingConsentUpdateNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;messagingSessionStarted&lt;/b&gt;: @see {@link MessagingSessionInitializedNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;messagingSessionRenewed&lt;/b&gt;: @see {@link MessagingSessionInitializedNotification}&lt;/li&gt; * &lt;/ul&gt; * &lt;/li&gt; * &lt;li&gt;Sandbox Events * &lt;ul&gt; * &lt;li&gt;&lt;b&gt;sendMessage&lt;/b&gt;: @see {@link SendMessageSimulatorNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;makeVoiceCall&lt;/b&gt;: @see {@link MakeVoiceCallSimulatorNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;sendCustomerPayment&lt;/b&gt;: @see {@link CustomerPaymentSimulatorNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;sendChannelPayment&lt;/b&gt;: @see {@link SendChannelPaymentSimulatorNotification}&lt;/li&gt; * &lt;li&gt;&lt;b&gt;checkoutPayment&lt;/b&gt;: @see {@link CustomerPaymentSimulatorNotification}&lt;/li&gt; * &lt;/ul&gt; * &lt;/li&gt; * &lt;/ul&gt; * @typedef {string} Event */ /** * An object representing a message body * @typedef {Object} SimulatorMessageBody * @property {string} [text] * @property {Media} [media] * @property {Location} [location] * @property {Email} [email] * @property {UssdInput} [ussd] * @property {VoiceCallInput} [voice] */ /** * An object representing a ussd input * @typedef {Object} UssdInput * @property {string} text * @property {string} status one of [active, incomplete, completed, app_error] */ /** * An object representing a voice call input * @typedef {Object} VoiceCallInput * @property {string} direction one of [outbound, inbound] * @property {string} status one of [queued, answered, ringing, active, dialing, dial_completed, bridged, enqueued, dequeued, transferred, transfer_completed, completed, insufficient_credit, not_answered, invalid_phone_number, destination_not_supported, decommissioned_customerid, expired, invalid_channel_number, application_error] * @property {number} startedAt * @property {string} hangupCause one of [unallocated_number, user_busy, normal_clearing, no_user_response, no_answer, subscriber_absent, call_rejected, normal_unspecified, normal_temporary_failure, service_unavailable, recovery_on_timer_expire, originator_cancel, lose_race, user_not_registered] * @property {string} dtmfDigits * @property {string} recordingUrl * @property {VoiceCallDialInput} dialData * @property {VoiceCallQueueInput} queueData */ /** * An object representing a voice call dial input * @typedef {Object} VoiceCallDialInput * @property {string} destinationNumber * @property {number} startedAt * @property {number} duration */ /** * An object representing a voice call queue input * @typedef {Object} VoiceCallQueueInput * @property {string} destinationNumber * @property {number} enqueuedAt * @property {number} dequeuedAt * @property {string} dequeuedToNumber * @property {string} dequeuedToSessionId * @property {number} queueDuration */ /** * An object representing a customer's payment source or destination * @typedef {Object} CustomerPayment * @property {CustomerNumber} customerNumber * @property {PaymentChannelNumber} channelNumber */ /** * An object representing a channel payment source or destination * @typedef {Object} ChannelPayment * @property {string} account * @property {NetworkCode} channelCode The telco's network code. * @property {PaymentChannelNumber} channelNumber */ /** * An object representing wallet * @typedef {Object} Wallet * @property {string} customerId * @property {string} walletId */ /** * An object representing purse * @typedef {Object} Purse * @property {string} purseId */ /** * An object representing a payment channel * @typedef {Object} PaymentChannelNumber * @property {string} number * @property {string} channel number provider. Must be one of ['cellular', 'airtime'] */ /** * An object representing a messaging channel number * @typedef {Object} MessagingChannelNumber * @property {string} number * @property {string} channel one of [sms,telegram,whatsapp,email,messenger,voice] */ /** * * @typedef {Object} CustomerStateUpdateReply * @property {string} customerId * @property {boolean} status * @property {string} description */ /** * * @typedef {Object} ConsentUpdateReply * @property {string} status * @property {string} description * @property {string} customerId */ /** * * @typedef {Object} MessageReply * @property {string} status one of [queued, sent, delivered, read, received, session_initiated, failed, no_consent, no_capability, expired, no_session_in_progress, other_session_in_progress, invalid_reply_token, invalid_channel_number, not_supported, invalid_reply_to_message_id, invalid_customer_id, duplicate_request , tag_not_found, customer_number_not_found, decommissioned_customerid, rejected, invalid_request, application_error] * @property {string} description * @property {string} customerId * @property {string} sessionId * @property {string} messageId */ /** * An number representing a network code. Examples include: * &lt;ul&gt;&lt;li&gt;&lt;code&gt;62006&lt;/code&gt;: AirtelTigo Ghana&lt;/li&gt;&lt;li&gt;&lt;code&gt;62002&lt;/code&gt;: Vodafone Ghana&lt;/li&gt;&lt;li&gt;&lt;code&gt;62001&lt;/code&gt;: MTN Ghana&lt;/li&gt;&lt;li&gt;&lt;code&gt;62120&lt;/code&gt;: Airtel Nigeria&lt;/li&gt;&lt;li&gt;&lt;code&gt;62130&lt;/code&gt;: MTN Nigeria&lt;/li&gt;&lt;li&gt;&lt;code&gt;62150&lt;/code&gt;: Glo Nigeria&lt;/li&gt;&lt;li&gt;&lt;code&gt;62160&lt;/code&gt;: Etisalat Nigeria&lt;/li&gt;&lt;li&gt;&lt;code&gt;63510&lt;/code&gt;: MTN Rwanda&lt;/li&gt;&lt;li&gt;&lt;code&gt;63513&lt;/code&gt;: Tigo Rwanda&lt;/li&gt;&lt;li&gt;&lt;code&gt;63514&lt;/code&gt;: Airtel Rwanda&lt;/li&gt;&lt;li&gt;&lt;code&gt;63601&lt;/code&gt;: EthioTelecom Ethiopia&lt;/li&gt;&lt;li&gt;&lt;code&gt;63902&lt;/code&gt;: Safaricom Kenya&lt;/li&gt;&lt;li&gt;&lt;code&gt;63903&lt;/code&gt;: Airtel Kenya&lt;/li&gt;&lt;li&gt;&lt;code&gt;63907&lt;/code&gt;: Orange Kenya&lt;/li&gt;&lt;li&gt;&lt;code&gt;63999&lt;/code&gt;: Equitel Kenya&lt;/li&gt;&lt;li&gt;&lt;code&gt;64002&lt;/code&gt;: Tigo Tanzania&lt;/li&gt;&lt;li&gt;&lt;code&gt;64004&lt;/code&gt;: Vodacom Tanzania&lt;/li&gt;&lt;li&gt;&lt;code&gt;64005&lt;/code&gt;: Airtel Tanzania&lt;/li&gt;&lt;li&gt;&lt;code&gt;64101&lt;/code&gt;: Airtel Uganda&lt;/li&gt;&lt;li&gt;&lt;code&gt;64110&lt;/code&gt;: MTN Uganda&lt;/li&gt;&lt;li&gt;&lt;code&gt;64114&lt;/code&gt;: Africell Uganda&lt;/li&gt;&lt;li&gt;&lt;code&gt;64501&lt;/code&gt;: Airtel Zambia&lt;/li&gt;&lt;li&gt;&lt;code&gt;64502&lt;/code&gt;: MTN Zambia&lt;/li&gt;&lt;li&gt;&lt;code&gt;65001&lt;/code&gt;: TNM Malawi&lt;/li&gt;&lt;li&gt;&lt;code&gt;65010&lt;/code&gt;: Airtel Malawi&lt;/li&gt;&lt;li&gt;&lt;code&gt;65501&lt;/code&gt;: Vodacom South Africa&lt;/li&gt;&lt;li&gt;&lt;code&gt;65502&lt;/code&gt;: Telkom South Africa&lt;/li&gt;&lt;li&gt;&lt;code&gt;65507&lt;/code&gt;: CellC South Africa&lt;/li&gt;&lt;li&gt;&lt;code&gt;65510&lt;/code&gt;: MTN South Africa&lt;/li&gt;&lt;li&gt;&lt;code&gt;99999&lt;/code&gt;: Athena (This is a custom networkCode that only applies when working in the sandbox environment).&lt;/li&gt;&lt;/ul&gt; * @typedef {number} NetworkCode */ × Search results Close "},"client.js.html":{"id":"client.js.html","title":"Source: client.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: client.js /* eslint-disable max-len */ /* global window */ /* eslint-disable no-underscore-dangle */ const validate = require('validate.js'); const { Single } = require('rsocket-flowable'); const { ElarianMessages, addMessage, getStatusString, getMediaTypeString, getChannelProviderString, getMessageReactionString, getCustomerEventDirectionString, getCustomerNumberProviderString, getMessageSessionEndReasonString, getMessageConsentUpdateActionString, } = require('./utils'); const { AppDataUpdate, DataMapValue, PaymentStatus, PaymentChannel, VoiceCallStatus, MessagingChannel, UssdSessionStatus, VoiceCallHangupCause, MessageDeliveryStatus, ServerToAppNotification, MessagingConsentUpdateStatus, ServerToAppNotificationReply, ServerToSimulatorNotification, ServerToSimulatorNotificationReply, } = ElarianMessages; const { connectRSocket } = require('./utils'); const defaultConfigOptions = { resumable: false, lifetime: 60000, keepAlive: 1000, notificationTimeout: 5000, }; /** * Instantiate an elarian client. You have to call connect() on then client to start using it * @class * @param {ClientConfig} config */ function Client(config) { const opts = { ...config, isSimulator: config.isSimulator === true, }; const constraints = { appId: { type: 'string', presence: true, }, orgId: { type: 'string', presence: true, }, apiKey: { type: 'string', }, authToken: { type: 'string', presence: this.platform.isBrowser, }, allowNotifications: { type: 'boolean', }, isSimulator: { type: 'boolean', }, options: { type: 'object', }, }; if (!opts.apiKey &amp;&amp; !opts.authToken) { throw new Error('Either one of apiKey or authToken is required'); } const error = validate(opts, constraints); if (error) { throw error; } this._client = null; this._socket = null; this.options = opts; const configOpts = opts.options || {}; this.configOptions = { lifetime: configOpts.lifetime || defaultConfigOptions.lifetime, resumable: configOpts.resumable || defaultConfigOptions.resumable, keepAlive: configOpts.keepAlive || defaultConfigOptions.keepAlive, serializer: configOpts.serializer || { type: 'text', serialize: (data) =&gt; JSON.stringify(data), deserialize: (data) =&gt; { try { return JSON.parse(data); } catch (err) { this.platform.log.warn(`Failed to deserialize ${data}: ${err.message}`); } return data; }, }, // eslint-disable-next-line max-len notificationTimeout: configOpts.notificationTimeout || defaultConfigOptions.notificationTimeout, }; this.eventListeners = { // debug data: null, // Connection error: null, closed: null, pending: null, connected: null, connecting: null, }; /** * Connecto to elarian servers * @returns {Elarian} this instance */ this.connect = function connect({ host, port } = {}) { connectRSocket({ ...this.options, authToken: this.options.authToken, apiKey: this.options.authToken ? null : this.options.apiKey, }, { host, port, ...this.configOptions, platform: this.platform, setSocket: (socket) =&gt; { this._socket = socket; }, getConnectionHandlers: () =&gt; ({ error: (err) =&gt; { if (this.eventListeners.error) { this.eventListeners.error(err); } }, closed: () =&gt; { this.disconnect(); if (this.eventListeners.closed) { this.eventListeners.closed(); } }, pending: this.eventListeners.pending, connecting: this.eventListeners.connecting, }), notificationHandler: this._notificationHandler(this), }).then(({ client }) =&gt; { this._client = client; if (this.eventListeners.connected) { this.eventListeners.connected(); } this._lifetimeId = setInterval(() =&gt; {}, 10000); }).catch((ex) =&gt; { if (this.eventListeners.error) { this.eventListeners.error(ex); } }); return this; }; this.getSocket = function getSocket() { if (!this._socket) { throw new Error('Client is not connected'); } return this._socket; }; /** * Check if client is connected * @returns {boolean} */ this.isConnected = function isConnected() { return this._client !== null &amp;&amp; this._socket !== null; }; /** * Disconnect from the elarian server */ this.disconnect = function disconnect() { if (this._client) { this._client.close(); clearInterval(this._lifetimeId); } this._client = null; this._socket = null; }; const cleanup = (code) =&gt; { this.platform.log.warn(`Disconnecting from API server(${code})`); this.disconnect(); if (!this.platform.isBrowser) { process.exit(code); } }; if (this.platform.isBrowser) { window.onbeforeunload = cleanup; } else { process.on('SIGINT', cleanup.bind(null)); process.on('SIGQUIT', cleanup.bind(null)); process.on('SIGTERM', cleanup.bind(null)); } } const cleanUpNotificationPayload = (event, data) =&gt; { /* eslint-disable no-param-reassign */ switch (event) { // App case 'reminder': data.reminder.payload = data.reminder.payload.value; data.reminder.remindAt = data.reminder.remindAt.seconds; data.reminder.interval = data.reminder.interval ? data.reminder.interval.seconds : undefined; break; case 'messagingSessionStarted': case 'messagingSessionRenewed': case 'messagingSessionEnded': data.sessionId = data.sessionId.value; data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; if (data.expiresAt) { data.expiresAt = data.expiresAt.seconds; } if (data.duration) { data.duration = data.duration.seconds; } if (data.reason) { data.reason = getMessageSessionEndReasonString(data.reason); } break; case 'messageStatus': data.status = getStatusString(data.status, MessageDeliveryStatus); break; case 'receivedMessage': data.sessionId = data.sessionId ? data.sessionId.value : undefined; data.inReplyTo = data.inReplyTo ? data.inReplyTo.value : undefined; data.parts = data.partsList.map((part) =&gt; { if (part.ussd) { return { ussd: { text: part.ussd.text.value, status: getStatusString(part.ussd.status, UssdSessionStatus), }, }; } if (part.location) { return { location: { latitude: part.location.latitude, longitude: part.location.longitude, label: part.location.label ? part.location.label.value : undefined, address: part.location.address ? part.location.address.value : undefined, }, }; } if (part.media) { return { media: { url: part.media.url, type: getMediaTypeString(part.media.media), }, }; } if (part.voice) { return { voice: { ...part.voice, dtmfDigits: part.voice.dtmfDigits ? part.voice.dtmfDigits.value : undefined, startedAt: part.voice.startedAt ? part.voice.startedAt.seconds : undefined, recordingUrl: part.voice.recordingUrl ? part.voice.recordingUrl.value : undefined, status: getStatusString(part.voice.status, VoiceCallStatus), direction: getCustomerEventDirectionString(part.voice.direction), hangupCause: getChannelProviderString(part.voice.hangupCause || 0, VoiceCallHangupCause, /^VOICE_CALL_HANGUP_CAUSE_/), }, }; } if (part.email) { return { email: part.email, }; } return { text: part.text, }; }); data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; // Assumes only one part per type switch (data.channelNumber.channel) { case 'ussd': data.input = data.parts.filter((i) =&gt; Object.keys(i).includes('ussd')).map((i) =&gt; i.ussd).pop(); break; case 'voice': data.voice = data.parts.filter((i) =&gt; i.voice).map((i) =&gt; i.voice).pop(); break; case 'sms': case 'whatsapp': case 'telegram': case 'fb_messenger': data.text = data.parts.filter((i) =&gt; i.text).map((i) =&gt; i.text).pop(); data.media = data.parts.filter((i) =&gt; i.media).map((i) =&gt; i.media).pop(); data.location = data.parts.filter((i) =&gt; i.location).map((i) =&gt; i.location).pop(); break; case 'email': data.email = data.parts.filter((i) =&gt; i.email).map((i) =&gt; i.location).pop(); break; default: break; } delete data.parts; delete data.partsList; break; case 'paymentStatus': data.status = getStatusString(data.status, PaymentStatus); break; case 'receivedPayment': data.status = getStatusString(data.status, PaymentStatus); data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, PaymentChannel), }; break; case 'walletPaymentStatus': data.status = getStatusString(data.status, PaymentStatus); break; case 'messagingConsentUpdate': data.sessionId = data.sessionId.value; data.status = getStatusString(data.status, MessagingConsentUpdateStatus); data.update = getMessageConsentUpdateActionString(data.update); data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; break; case 'customerActivity': data.sessionId = data.sessionId.value; data.source = data.source.value; break; case 'sentMessageReaction': data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; data.reaction = getMessageReactionString(data.reaction); break; // Simulator case 'sendMessage': case 'makeVoiceCall': if (data.sessionId) { data.sessionId = data.sessionId.value; } data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, MessagingChannel), }; break; case 'checkoutPayment': case 'sendChannelPayment': case 'sendCustomerPayment': if (data.account) { data.account = data.account.value; } if (data.channelNumber) { data.channelNumber = { number: data.channelNumber.number, channel: getChannelProviderString(data.channelNumber.channel, PaymentChannel), }; } if (data.channel) { data.channel = getChannelProviderString(data.channel, PaymentChannel); } break; default: break; } if (data.customerNumber) { data.customerNumber = { number: data.customerNumber.number, provider: getCustomerNumberProviderString(data.customerNumber.provider), partition: data.customerNumber.partition ? data.customerNumber.partition.value : undefined, }; } /* eslint-enable no-param-reassign */ return data; }; // eslint-disable-next-line no-underscore-dangle Client.prototype._notificationHandler = (client) =&gt; (incomingPayload) =&gt; { let event; const { log } = client.platform; const { isSimulator, notificationTimeout = 5000 } = client.options; let response = isSimulator ? new ServerToSimulatorNotificationReply() : new ServerToAppNotificationReply(); const handlePayload = async () =&gt; { let notif = isSimulator ? ServerToSimulatorNotification.deserializeBinary(incomingPayload.data).toObject() : ServerToAppNotification.deserializeBinary(incomingPayload.data).toObject(); if (!isSimulator) { notif = notif.customer || notif.purse; } const events = Object.keys(notif); event = events.find((i) =&gt; !['orgId', 'appId', 'createdAt', 'customerId', 'purseId', 'appData'].includes(i) &amp;&amp; notif[i]); const data = cleanUpNotificationPayload(event, { ...notif[event] }); if (!isSimulator) { data.orgId = notif.orgId; data.appId = notif.appId; if (notif.purseId) { data.purseId = notif.purseId; } data.customerId = notif.customerId; data.createdAt = notif.createdAt ? notif.createdAt.seconds : undefined; } const globalListener = client.eventListeners.data; if (globalListener) { await globalListener(event, data, notif); } let channel; if (event === 'receivedMessage') { // Split messaging into multiple events channel = data.channelNumber.channel; switch (channel) { case 'voice': event = 'voiceCall'; break; case 'ussd': event = 'ussdSession'; break; case 'sms': event = 'receivedSms'; break; case 'fb_messenger': event = 'receivedFbMessenger'; break; case 'telegram': event = 'receivedTelegram'; break; case 'whatsapp': event = 'receivedWhatsapp'; break; case 'email': event = 'receivedEmail'; break; default: break; } } const listener = client.eventListeners[event]; let incomingAppData = notif.appData || {}; const { serializer } = client.configOptions; incomingAppData = serializer.type === 'text' ? incomingAppData.stringVal : incomingAppData.bytesVal; incomingAppData = incomingAppData ? serializer.deserialize(incomingAppData) : undefined; let outgoingAppData = incomingAppData; if (listener) { let customer; if (notif.customerId &amp;&amp; !isSimulator) { customer = new client.Customer({ id: notif.customerId || data.customerId, number: data.customerNumber ? data.customerNumber.number : undefined, provider: data.customerNumber ? data.customerNumber.provider : undefined, partition: data.customerNumber ? data.customerNumber.partition : undefined, }); } // eslint-disable-next-line no-async-promise-executor const listenerExec = new Promise(async (resolve, reject) =&gt; { try { if (customer &amp;&amp; !customer.customerNumber) { try { // hack to get customer number await customer.getState(); } catch (error) { log.warn(`${event}: Failed to fetch customer state ${customer.customerId} `, error); } } const cb = (payload, appData) =&gt; resolve({ payload, appData }); listener(data, customer, incomingAppData, cb); } catch (ex) { reject(ex); } }); const { payload, appData } = await Promise.race([ listenerExec, new Promise((resolve) =&gt; setTimeout(resolve, notificationTimeout, {})), ]); if (appData) { outgoingAppData = appData; } if (payload) { switch (channel) { case 'voice': // payload is actions[] response = addMessage(response, { body: { voice: payload, }, }); break; case 'ussd': // payload is { text, isTerminal } response = addMessage(response, { body: { ussd: payload, }, }); break; default: response = addMessage(response, payload); break; } } } if (outgoingAppData) { const appDataUpdate = new DataMapValue(); const serializedValue = serializer.serialize(outgoingAppData); switch (serializer.type) { case 'text': appDataUpdate.setStringVal(serializedValue); break; case 'binary': appDataUpdate.setBytesValue(serializedValue); break; default: throw new Error('Invalid serializer type'); } response = response.setDataUpdate( new AppDataUpdate() .setData(appDataUpdate), ); } return response; }; return new Single((subscriber) =&gt; { subscriber.onSubscribe(); handlePayload() .then((data) =&gt; { try { subscriber.onComplete({ data: Buffer.from(data.serializeBinary()) }); } catch (error) { log.error(`NotificationReplyError::${event}: `, error.message || error); } }) .catch((error) =&gt; { // FIXME: This returns a valid response to avoid retries... // ideally subscriber.onError(error) should be the response try { log.error(`NotificationDefaultError::${event}: `, error.message || error); subscriber.onComplete({ data: Buffer.from(response.serializeBinary()) }); } catch (ex) { log.error(`NotificationError::${event}: `, ex.message || ex); } }); }); }; /** * Register a listener to watch out for events. Can also be called with &lt;code&gt;client.on(event,listener)&lt;/code&gt; * @param {Event} event The event whose listener to register * @param {NotificationHandler} handler A function that reacts to events * @returns {Client} this instance */ Client.prototype.registerNotificationHandler = function registerNotificationHandler(event, handler) { const events = Object.keys(this.eventListeners); if (!events.includes(event)) { throw new Error(`Unexpected event ${event}. Must be one of ${events}`); } this.eventListeners[event] = handler; return this; }; /** * Register a listener to watch out for events. Can also be called with &lt;code&gt;client.registerListerner(event,listener)&lt;/code&gt; * @param {Event} event The event whose listener to register * @param {NotificationHandler} handler A function that reacts to events * @returns {Client} this instance */ Client.prototype.on = function on(event, handler) { return this.registerNotificationHandler(event, handler); }; module.exports = Client; × Search results Close "},"customer.js.html":{"id":"customer.js.html","title":"Source: customer.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: customer.js /* eslint-disable no-underscore-dangle */ const validate = require('validate.js'); const { ElarianMessages, getValidCollectionKeys, } = require('./utils'); const { CustomerNumberProvider } = ElarianMessages; /** * A customer is your end-user, represented by a number (from a cellular, facebook or telegram) * @class * @param {CustomerParams} params */ function Customer(params) { const constraints = { id: { type: 'string', }, number: { type: 'string', }, provider: { type: 'string', inclusion: getValidCollectionKeys(CustomerNumberProvider), }, partition: { type: 'string', }, }; const error = validate(params, constraints); if (error) { let message = ''; Object.keys(error).forEach((key) =&gt; { message += `${key}: ${error[key].join(',')}\\n`; }); throw new Error(message); } this.customerNumber = null; this.customerId = params.id; if (params.number) { this.customerNumber = { number: params.number, provider: params.provider, partition: params.partition, }; } this.identityState = {}; this.messagingState = {}; this.paymentState = {}; this.activityState = {}; if (this.client &amp;&amp; this.client.isConnected() &amp;&amp; this.customerNumber) { this.client._createCustomer(this.customerNumber) .then((res) =&gt; { if (res.status &amp;&amp; res.customerId) { this.customerId = res.customerId; } }) .catch((ex) =&gt; this.client.platform.log.error(`Failed to create customer ${ex}`)); } /* eslint-disable no-use-before-define */ /** * Fetch the customer's current state. * @returns {CustomerState} */ this.getState = async () =&gt; { const data = await this.client._getCustomerState(this); this.customerId = data.customerId; const numbers = [ ...(data.messagingState ? data.messagingState.channels : []) .map((i) =&gt; Object.keys(i).map((ki) =&gt; (i[ki] ? i[ki].customerNumber : null))) .flat() .filter((j) =&gt; j !== null), ...(data.paymentState ? data.paymentState.customerNumbers : []), ...(data.activityState ? data.activityState.customerNumbers : []), ]; if (numbers.length &amp;&amp; !this.customerNumber) { const candidate = numbers.find((i) =&gt; i.number); this.customerNumber = candidate; } this.identityState = data.identityState; this.paymentState = data.paymentState; this.messagingState = data.messagingState; this.activityState = data.activityState; return data; }; /** * Merge otherCustomer's state into this customer's state and discard otherCustomer * @param {Customer} otherCustomer * @returns {CustomerStateUpdateReply} */ this.adoptState = async (otherCustomer) =&gt; this.client._adoptCustomerState(this, otherCustomer); /** * Send a message to the customer from the specified channel number. * @param {MessagingChannelNumber} channelNumber * @param {Message} message * @returns {MessageReply} */ // eslint-disable-next-line max-len this.sendMessage = async (channelNumber, message) =&gt; this.client._sendMessage(this, channelNumber, message); /** * Reply to a message * @param {string} messageId * @param {Message} message * @returns {MessageReply} */ // eslint-disable-next-line max-len this.replyToMessage = async (messageId, message) =&gt; this.client._replyToMessage(this, messageId, message); /** * Initiate a customer activity * @param {string} source * @param {Activity} activity * @returns {CustomerStateUpdateReply} */ // eslint-disable-next-line max-len this.updateActivity = async (source, activity) =&gt; this.client._updateCustomerActivity(this.customerNumber, source, activity); /** * Allow or block a customer from receiving messages from a channel * @param {MessagingChannelNumber} channelNumber * @param {string} action allow or block * @returns {ConsentUpdateReply} */ // eslint-disable-next-line max-len this.updateMessagingConsent = async (channelNumber, action) =&gt; this.client._updateMessagingConsent(this, channelNumber, action); /** * Fetches the customer's app data and lock it from fetching(for up to &lt;b&gt;90s&lt;/b&gt;) * until next call to update app data. * @returns {LeasedAppData} */ this.leaseAppData = async () =&gt; this.client._leaseCustomerAppData(this); /** * Sets some app data on the customer. * Values in the data object can either be strings or buffers, * depending on the set serializer. @see {@link ConnectionOptions} * @param {Object} data * @returns {CustomerStateUpdateReply} */ this.updateAppData = async (data) =&gt; this.client._updateCustomerAppData(this, data); /** * Remove customer's app data * @returns {CustomerStateUpdateReply} */ this.deleteAppData = async () =&gt; this.client._deleteCustomerAppData(this); /** * Fetch customer metadata * @returns {Object} */ this.getMetadata = async () =&gt; { const state = await this.getState(); return (state.identityState || {}).metadata || {}; }; /** * Sets some metadata on the customer. * Values in the metadata object can either be strings or buffers, * depending on the set serializer * @param {Object} metadata * @returns {CustomerStateUpdateReply} */ this.updateMetadata = async (metadata) =&gt; this.client._updateCustomerMetadata(this, metadata); /** * Remove some metadata from a customer. &lt;code&gt;keys&lt;/code&gt; is an array of strings * @param {string[]} keys * @returns {CustomerStateUpdateReply} */ this.deleteMetadata = async (keys) =&gt; this.client._deleteCustomerMetadata(this, keys); /** * Fetch customer secondaryIds * @returns {SecondaryId[]} */ this.getSecondaryIds = async () =&gt; { const state = await this.getState(); return (state.identityState || {}).secondaryIds || []; }; /** * Update a customer's secondary Ids * @param {SecondaryId[]} secondaryIds * @returns {CustomerStateUpdateReply} */ // eslint-disable-next-line max-len this.updateSecondaryIds = async (secondaryIds) =&gt; this.client._updateCustomerSecondaryIds(this, secondaryIds); /** * Remove some secondary Ids from a customer * @param {SecondaryId[]} secondaryIds * @returns {CustomerStateUpdateReply} */ // eslint-disable-next-line max-len this.deleteSecondaryIds = async (secondaryIds) =&gt; this.client._deleteCustomerSecondaryIds(this, secondaryIds); /** * Fetch customer tags * @returns {Tag[]} */ this.getTags = async () =&gt; { const state = await this.getState(); return (state.identityState || {}).tags || []; }; /** * Update a customer's tag list. * @param {Tag[]} tags * @returns {CustomerStateUpdateReply} */ this.updateTags = async (tags) =&gt; this.client._updateCustomerTags(this, tags); /** * Remove some tags from a customer * @param {string[]} tags * @returns {CustomerStateUpdateReply} */ this.deleteTags = async (keys) =&gt; this.client._deleteCustomerTags(this, keys); /** * Set a reminder to be triggered at the specified time for a particular customer * @param {Reminder} reminder * @returns {CustomerStateUpdateReply} */ this.addReminder = async (reminder) =&gt; this.client._addCustomerReminder(this, reminder); /** * Cancels a previously set reminder with the key &lt;code&gt;key&lt;/code&gt; on the customer * @param {string} key * @returns {CustomerStateUpdateReply} */ this.cancelReminder = async (key) =&gt; this.client._cancelCustomerReminder(this, key); /** * Initiate a voice call to customer from channelNumber * @param {MessagingChannelNumber} channelNumber * @param {VoiceAction[]} actions */ /* this.makeVoiceCall = async (channelNumber, actions = []) =&gt; { if (channelNumber.channel !== 'voice') { throw new Error('Invalid channel number. Channel must be voice'); } const { customerNumber } = this; if (!customerNumber) { // FIXME: Have Elarian return the customer number on fetch state? throw new Error('customerNumber is not setup on this customer'); } return this.sendMessage(channelNumber, { body: { voice: actions } }); }; */ } module.exports = Customer; × Search results Close "},"elarian.js.html":{"id":"elarian.js.html","title":"Source: elarian.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: elarian.js const Client = require('./client'); const Customer = require('./customer'); /** * Instantiate an elarian client. You have to call connect() on then client to start using it * @class * @extends Client * @param {ClientConfig} config */ function Elarian(config) { Client.call(this, config); this.eventListeners = { ...this.eventListeners, // Core reminder: null, messageStatus: null, paymentStatus: null, receivedPayment: null, customerActivity: null, sentMessageReaction: null, walletPaymentStatus: null, messagingSessionEnded: null, messagingConsentUpdate: null, messagingSessionStarted: null, messagingSessionRenewed: null, // Virtual voiceCall: null, ussdSession: null, receivedSms: null, receivedEmail: null, receivedTelegram: null, receivedWhatsapp: null, receivedFbMessenger: null, }; Customer.prototype.client = this; /** * A customer object. @see {@link Customer} * @class */ this.Customer = Customer; } Elarian.prototype = Object.create(Client.prototype, { constructor: Elarian }); module.exports = Elarian; × Search results Close "},"state.js.html":{"id":"state.js.html","title":"Source: state.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: state.js /* eslint-disable no-underscore-dangle */ const Elarian = require('./elarian'); const Customer = require('./customer'); const { addTag, addIndices, addCustomer, addReminder, ElarianMessages, addOtherCustomer, addCustomerNumber, addCustomerIndices, getCustomerNumberProviderString, getChannelProviderString, } = require('./utils'); const { DataMapValue, AppToServerCommand, AppToServerCommandReply, PaymentChannel, MessagingChannel, CreateCustomerCommand, CustomerActivityCommand, GetCustomerStateCommand, DeleteCustomerTagCommand, UpdateCustomerTagCommand, AdoptCustomerStateCommand, AddCustomerReminderCommand, LeaseCustomerAppDataCommand, DeleteCustomerAppDataCommand, DeleteCustomerMetadataCommand, UpdateCustomerAppDataCommand, CancelCustomerReminderCommand, AddCustomerReminderTagCommand, UpdateCustomerMetadataCommand, DeleteCustomerSecondaryIdCommand, UpdateCustomerSecondaryIdCommand, CancelCustomerReminderTagCommand, } = ElarianMessages; /** * Set a reminder to be triggered at the specified time for customers with the particular tag * @param {Tag} tag * @param {Reminder} reminder * @returns {TagUpdateReply} * @memberof Elarian */ Elarian.prototype.addCustomerReminderByTag = function addCustomerReminderByTag(tag, reminder) { const socket = this.getSocket(); if (!reminder || !tag) { throw new Error('reminder and tag are required'); } let cmd = new AddCustomerReminderTagCommand(); cmd = addTag(cmd, tag); cmd = addReminder(cmd, reminder); const req = new AppToServerCommand() .setAddCustomerReminderTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getTagCommand(); const result = { status: res.getStatus(), description: res.getDescription(), workId: (res.getWorkId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Cancels a previously set reminder with tag &lt;code&gt;tag&lt;/code&gt; and key &lt;code&gt;key&lt;/code&gt; * @param {Tag} tag * @param {string} key * @returns {TagUpdateReply} * @memberof Elarian */ Elarian.prototype.cancelCustomerReminderByTag = function cancelCustomerReminderByTag(tag, key) { const socket = this.getSocket(); if (!key || !tag) { throw new Error('key and tag are required'); } let cmd = new CancelCustomerReminderTagCommand() .setKey(key); cmd = addTag(cmd, tag); const req = new AppToServerCommand() .setCancelCustomerReminderTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getTagCommand(); const result = { status: res.getStatus(), description: res.getDescription(), workId: (res.getWorkId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Create a customer * @param {*} customerNumber * @returns {CustomerStateUpdateReply} */ Elarian.prototype._createCustomer = function createCustomer(customerNumber) { const socket = this.getSocket(); if (!customerNumber || !customerNumber.number || !customerNumber.provider) { throw new Error('Invalid customer number'); } let cmd = new CreateCustomerCommand(); cmd = addCustomer(cmd, { customerNumber }); const req = new AppToServerCommand() .setCreateCustomer(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Fetch the customer's current state. * @param {Customer} customer * @returns {CustomerState} * @ignore */ Elarian.prototype._getCustomerState = function getCustomerState(customer) { if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } const socket = this.getSocket(); let cmd = new GetCustomerStateCommand(); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setGetCustomerState(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getGetCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), data: (res.getData() || { toObject: () =&gt; undefined, }).toObject(), }; if (!result.status) { throw new Error(result.description); } // eslint-disable-next-line max-len if (result.data.identityState &amp;&amp; Object.keys(result.data.identityState).length) { const { serializer: { type, deserialize } } = this.configOptions; const deserializeKey = type === 'text' ? 'stringVal' : 'bytesVal'; const unprocessedState = result.data.identityState; const identityState = { tags: unprocessedState.tagsList.map((i) =&gt; ({ key: i.mapping.key, value: i.mapping.value.value, expiration: i.expiresAt.seconds, })), secondaryIds: unprocessedState.secondaryIdsList.map((i) =&gt; ({ key: i.mapping.key, value: i.mapping.value.value, expiration: i.expiresAt.seconds, })), metadata: Object.assign( {}, ...unprocessedState.metadataMap.map((i) =&gt; ({ [i[0]]: deserialize(i[1][deserializeKey]), })), ), }; result.data.identityState = identityState; } // eslint-disable-next-line max-len if (result.data.paymentState &amp;&amp; Object.keys(result.data.paymentState).length) { const entry = result.data.paymentState; result.data.paymentState = { wallets: entry.walletsMap, transactionLogs: entry.transactionLogList, pendingTransactions: entry.pendingTransactionsList, customerNumbers: entry.customerNumbersList.map((i) =&gt; ({ number: i.number, provider: getCustomerNumberProviderString(i.provider), partition: i.partition ? i.partition.value : undefined, })), channelNumbers: entry.channelNumbersList.map((i) =&gt; ({ number: i.number, // eslint-disable-next-line max-len channel: getChannelProviderString(i.channel, PaymentChannel), })), }; } // eslint-disable-next-line max-len if (result.data.messagingState &amp;&amp; Object.keys(result.data.messagingState).length) { result.data.messagingState = { channels: result.data.messagingState.channelsList.map((ch) =&gt; { const state = { active: ch.active, blocked: ch.blocked, inSession: ch.inSession, }; Object.keys(state).forEach((key) =&gt; { if (state[key]) { state[key].customerNumber = state[key].customerNumber ? { number: state[key].customerNumber.number, provider: getCustomerNumberProviderString( state[key].customerNumber.provider, ), // eslint-disable-next-line max-len partition: state[key].customerNumber.partition ? state[key].customerNumber.partition.value : undefined, } : undefined; state[key].channelNumber = state[key].channelNumber ? { number: state[key].channelNumber.number, channel: getChannelProviderString( state[key].channelNumber.channel, MessagingChannel, ), } : undefined; } }); if (state.active) { state.active = { customerNumber: state.active.customerNumber, channelNumber: state.active.customerNumber, replyToken: state.active.replyToken ? { token: state.active.replyToken.token, // eslint-disable-next-line max-len expiresAt: state.active.replyToken.expiresAt.seconds, } : undefined, // eslint-disable-next-line max-len allowedAt: state.active.allowedAt ? state.active.allowedAt.seconds : undefined, }; } if (state.blocked) { state.blocked = { customerNumber: state.blocked.customerNumber, channelNumber: state.blocked.customerNumber, replyToken: state.blocked.replyToken ? { token: state.blocked.replyToken.token, // eslint-disable-next-line max-len expiresAt: state.blocked.replyToken.expiresAt.seconds, } : undefined, }; } if (state.inSession) { state.inSession = { appIds: state.inSession.appIdsList, sessionId: state.inSession.sessionId, customerNumber: state.inSession.customerNumber, channelNumber: state.inSession.customerNumber, replyToken: state.inSession.replyToken ? { token: state.inSession.replyToken.token, // eslint-disable-next-line max-len expiresAt: state.inSession.replyToken.expiresAt.seconds, } : undefined, // eslint-disable-next-line max-len allowedAt: state.inSession.allowedAt ? state.inSession.allowedAt.seconds : undefined, // eslint-disable-next-line max-len startedAt: state.inSession.startedAt ? state.inSession.startedAt.seconds : undefined, // eslint-disable-next-line max-len expiresAt: state.inSession.expiresAt ? state.inSession.expiresAt.seconds : undefined, }; } return state; }), messasges: result.data.messagingState.messagesList, sessions: result.data.messagingState.sessionsList, }; } // eslint-disable-next-line max-len if (result.data.activityState &amp;&amp; Object.keys(result.data.activityState).length) { const entry = result.data.activityState; result.data.activityState = { sessions: (entry.sessionsList || []).map((sess) =&gt; ({ appId: sess.appId, sessionId: sess.sessionId, activities: (sess.activitiesList || []).map((i) =&gt; ({ key: i.key, properties: i.propertiesMap.map((j) =&gt; ({ [j[0]]: j[1], // FIXME: What are the actual values? })), createdAt: i.createdAt ? i.createdAt.seconds : undefined, })), createdAt: sess.createdAt.seconds, updatedAt: sess.updatedAt.seconds, customerNumber: sess.customerNumber ? { number: sess.customerNumber.number, provider: getCustomerNumberProviderString( sess.customerNumber.provider, ), // eslint-disable-next-line max-len partition: sess.customerNumber.partition ? sess.customerNumber.partition.value : undefined, } : undefined, source: sess.source, })), customerNumbers: (entry.customerNumbersList || []).map((num) =&gt; ({ number: num.number, provider: getCustomerNumberProviderString( num.provider, ), // eslint-disable-next-line max-len partition: num.partition ? num.partition.value : undefined, })), }; } resolve(result.data); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Adopt another customer's state * @param {Customer} customer * @param {Customer} otherCustomer * @returns {CustomerStateUpdateReply} * @ignore */ Elarian.prototype._adoptCustomerState = async function adoptCustomerState(customer, otherCustomer) { const socket = this.getSocket(); if (!(customer instanceof Customer) || !(otherCustomer instanceof Customer)) { throw new Error('Invalid customer and/or otherCustomer'); } let { customerId } = customer; if (!customerId) { const state = await customer.getState(); customerId = state.customerId; } let cmd = new AdoptCustomerStateCommand() .setCustomerId(customerId); cmd = addOtherCustomer(cmd, otherCustomer); const req = new AppToServerCommand() .setAdoptCustomerState(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Update a customer's tag list * @param {Customer} customer * @param {Tag[]} tags * @returns {CustomerStateUpdateReply} * @ignore */ Elarian.prototype._updateCustomerTags = function updateCustomerTags(customer, tags) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!tags || !tags.length) { throw new Error('tags is required'); } let cmd = new UpdateCustomerTagCommand(); cmd = addCustomer(cmd, customer); cmd = addCustomerIndices(cmd, tags, 'setUpdatesList'); const req = new AppToServerCommand() .setUpdateCustomerTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Remove tags from a customer * @param {Customer} customer * @param {string[]} keys * @returns {CustomerStateUpdateReply} * @ignore */ Elarian.prototype._deleteCustomerTags = async function deleteCustomerTags(customer, keys) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!keys || !keys.length) { throw new Error('tags is required'); } let cmd = new DeleteCustomerTagCommand() .setDeletionsList(keys); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setDeleteCustomerTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Update a customer's secondary Ids * @param {Customer} customer * @param {SecondaryId[]} secondaryIds * @returns {CustomerStateUpdateReply} * @ignore */ // eslint-disable-next-line max-len Elarian.prototype._updateCustomerSecondaryIds = async function updateCustomerSecondaryIds(customer, secondaryIds) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!secondaryIds || !secondaryIds.length) { throw new Error('secondaryIds is required'); } let cmd = new UpdateCustomerSecondaryIdCommand(); cmd = addCustomer(cmd, customer); cmd = addCustomerIndices(cmd, secondaryIds, 'setUpdatesList'); const req = new AppToServerCommand() .setUpdateCustomerSecondaryId(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Delete a customer's secondary Ids * @param {Customer} customer * @param {SecondaryId[]} secondaryIds * @returns {CustomerStateUpdateReply} * @ignore */ // eslint-disable-next-line max-len Elarian.prototype._deleteCustomerSecondaryIds = function deleteCustomerSecondaryIds(customer, secondaryIds) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!secondaryIds || !secondaryIds.length) { throw new Error('secondaryIds is required'); } let cmd = new DeleteCustomerSecondaryIdCommand(); cmd = addCustomer(cmd, customer); cmd = addIndices(cmd, secondaryIds, 'setDeletionsList'); const req = new AppToServerCommand() .setDeleteCustomerSecondaryId(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Set a reminder to be triggered at the specified time for a particular customer * @param {Customer} customer * @param {Reminder} reminder * @returns {CustomerStateUpdateReply} * @ignore */ Elarian.prototype._addCustomerReminder = function addCustomerReminder(customer, reminder) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!reminder) { throw new Error('reminder is required'); } let cmd = new AddCustomerReminderCommand(); cmd = addCustomer(cmd, customer); cmd = addReminder(cmd, reminder); const req = new AppToServerCommand() .setAddCustomerReminder(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Cancels a previously set reminder with the key &lt;code&gt;key&lt;/code&gt; on the customer * @param {Customer} customer * @param {string} key * @returns {UpdateStatus} * @ignore */ Elarian.prototype._cancelCustomerReminder = function cancelCustomerReminder(customer, key) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!key) { throw new Error('key is required'); } let cmd = new CancelCustomerReminderCommand() .setKey(key); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setCancelCustomerReminder(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Sets some metadata on the customer. * Values in the metadata object can either be strings or buffers, * depending on your serializer. @see {@link Client} * @param {Customer} customer * @param {Object} metadata * @returns {CustomerStateUpdateReply} * @ignore */ Elarian.prototype._updateCustomerMetadata = function updateCustomerMetadata(customer, metadata) { const socket = this.getSocket(); const { serializer } = this.configOptions; if (!metadata) { throw new Error('metadata is required'); } let cmd = new UpdateCustomerMetadataCommand(); cmd = addCustomer(cmd, customer); Object.keys(metadata).forEach((key) =&gt; { const value = new DataMapValue(); const serializedValue = serializer.serialize(metadata[key]); if (serializedValue) { switch (serializer.type) { case 'text': value.setStringVal(serializedValue); break; case 'binary': value.setBytesValue(serializedValue); break; default: throw new Error('Invalid serializer type'); } cmd.getUpdatesMap().set(key, value); } }); const req = new AppToServerCommand() .setUpdateCustomerMetadata(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Remove some metadata from a customer. * @param {Customer} customer * @param {string[]} keys * @returns {CustomerStateUpdateReply} * @ignore */ Elarian.prototype._deleteCustomerMetadata = function deleteCustomerMetadata(customer, keys) { const socket = this.getSocket(); if (!keys || !keys.length) { throw new Error('keys are required'); } let cmd = new DeleteCustomerMetadataCommand() .setDeletionsList(keys); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setDeleteCustomerMetadata(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerState(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Sets some app data on the customer. * Value of the data object can either be a string or a buffer, * depending on your serializer. @see {@link ConnectionOptions} * @param {Customer} customer * @param {Object} data * @returns {CustomerStateUpdateReply} * @ignore */ Elarian.prototype._updateCustomerAppData = function updateCustomerAppData(customer, data) { const socket = this.getSocket(); const { serializer } = this.configOptions; if (!data) { throw new Error('data is required'); } let cmd = new UpdateCustomerAppDataCommand(); cmd = addCustomer(cmd, customer); const appData = new DataMapValue(); const serializedValue = serializer.serialize(data); switch (serializer.type) { case 'text': appData.setStringVal(serializedValue); break; case 'binary': appData.setBytesValue(serializedValue); break; default: throw new Error('Invalid serializer type'); } cmd.setUpdate(appData); const req = new AppToServerCommand() .setUpdateCustomerAppData(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Fetches the customer's app data and lock it from fetching(for up to &lt;b&gt;90s&lt;/b&gt;) * until next call to update app data. * @param {Customer} customer * @returns {LeasedAppData} * @ignore */ Elarian.prototype._leaseCustomerAppData = function leaseCustomerAppData(customer) { const socket = this.getSocket(); const { serializer } = this.configOptions; let cmd = new LeaseCustomerAppDataCommand(); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setLeaseCustomerAppData(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getLeaseCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), value: (res.getValue() || { toObject: () =&gt; undefined, }).toObject(), }; if (!result.status) { throw new Error(result.description); } if (result.value) { const item = serializer.type === 'text' ? result.value.stringVal : result.value.bytesVal; result.value = serializer.deserialize(item); } resolve(result.value || {}); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Remove customer's app data. * @param {Customer} customer * @returns {CustomerStateUpdateReply} * @ignore */ Elarian.prototype._deleteCustomerAppData = function deleteCustomerAppData(customer) { const socket = this.getSocket(); let cmd = new DeleteCustomerAppDataCommand(); cmd = addCustomer(cmd, customer); const req = new AppToServerCommand() .setDeleteCustomerAppData(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateCustomerAppData(); const result = { status: res.getStatus(), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; if (!result.status) { throw new Error(result.description); } resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Initiate a customer activity * @param {CustomerNumber} customerNumber * @param {string} source * @param {Activity} activity * @returns {CustomerStateUpdateReply} * @ignore */ // eslint-disable-next-line max-len Elarian.prototype._updateCustomerActivity = function updateCustomerActivity(customerNumber, source, activity) { const socket = this.getSocket(); const { sessionId, key, properties = {}, } = activity; let cmd = new CustomerActivityCommand(); cmd = cmd .setSessionId(sessionId) .setKey(key) .setSource(source); Object.keys(properties).forEach((name) =&gt; { cmd.getPropertiesMap().set(name, properties[name]); }); cmd = addCustomerNumber(cmd, customerNumber); const req = new AppToServerCommand() .setCustomerActivity(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (item) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(item.data) .getCustomerActivity(); const result = { status: res.getStatus(), description: res.getDescription(), transactionId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"authentication.js.html":{"id":"authentication.js.html","title":"Source: authentication.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: authentication.js const Elarian = require('./elarian'); const { ElarianMessages } = require('./utils'); const { AppToServerCommand, AppToServerCommandReply, GenerateAuthTokenCommand, } = ElarianMessages; /** * Generate a short-lived auth token to use instead of apiKey. Used for browser and mobile clients. * @returns {AuthToken} * @memberof Elarian */ Elarian.prototype.generateAuthToken = function generateAuthToken() { const socket = this.getSocket(); const cmd = new GenerateAuthTokenCommand(); const req = new AppToServerCommand() .setGenerateAuthToken(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getGenerateAuthToken(); const result = { token: res.getToken(), lifetime: res.getLifetime().getSeconds(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"payment.js.html":{"id":"payment.js.html","title":"Source: payment.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: payment.js const { ElarianMessages, addCashValue, getStatusString, addPaymentCounterParty, } = require('./utils'); const Elarian = require('./elarian'); const { PaymentStatus, AppToServerCommand, AppToServerCommandReply, InitiatePaymentCommand, } = ElarianMessages; /** * Initiate a payment transaction * @param {CustomerPayment|Wallet|Purse|ChannelPayment} debitParty * @param {CustomerPayment|Wallet|Purse|ChannelPayment} creditParty * @param {Cash} value * @returns {InitiatePaymentReply} * @memberof Elarian */ Elarian.prototype.initiatePayment = function initiatePayment(debitParty, creditParty, value) { const socket = this.getSocket(); let cmd = new InitiatePaymentCommand(); cmd = addPaymentCounterParty(cmd, debitParty, 'setDebitParty'); cmd = addPaymentCounterParty(cmd, creditParty, 'setCreditParty'); cmd = addCashValue(cmd, value); const req = new AppToServerCommand() .setInitiatePayment(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (item) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(item.data) .getInitiatePayment(); const result = { status: getStatusString(res.getStatus(), PaymentStatus), description: res.getDescription(), transactionId: (res.getTransactionId() || { getValue: () =&gt; undefined, }).getValue(), debitCustomerId: (res.getDebitCustomerId() || { getValue: () =&gt; undefined, }).getValue(), creditCustomerId: (res.getCreditCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"messaging.js.html":{"id":"messaging.js.html","title":"Source: messaging.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: messaging.js /* eslint-disable no-underscore-dangle */ const { ElarianMessages, addTag, addMessage, addCustomer, getStatusString, addCustomerNumber, getMessageConsentUpdateAction, getMessageDeliveryStatusString, getChannelProvider, } = require('./utils'); const Elarian = require('./elarian'); const Customer = require('./customer'); const { MessagingChannel, AppToServerCommand, SendMessageCommand, ReplyToMessageCommand, SendMessageTagCommand, MessageDeliveryStatus, MessagingChannelNumber, AppToServerCommandReply, MessagingConsentUpdateStatus, UpdateMessagingConsentCommand, } = ElarianMessages; /** * Send message by tag * @param {Tag} tag * @param {MessagingChannelNumber} channelNumber * @param {Message} message * @memberof Elarian * @returns {TagUpdateReply} */ Elarian.prototype.sendMessageByTag = function sendMessageByTag(tag, channelNumber, message) { const socket = this.getSocket(); let cmd = new SendMessageTagCommand() .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, MessagingChannel)), ); cmd = addTag(cmd, tag); cmd = addMessage(cmd, message); const req = new AppToServerCommand() .setSendMessageTag(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getTagCommand(); const result = { status: res.getStatus(), description: res.getDescription(), workId: (res.getWorkId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Send a message * @param {Customer} customer * @param {MessagingChannelNumber} channelNumber * @param {Message} message * @returns {MessageReply} * @ignore */ Elarian.prototype._sendMessage = function sendMessage(customer, channelNumber, message) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } if (!customer.customerNumber) { throw new Error('sendMessage() requires a customer with customerNumber'); } let cmd = new SendMessageCommand() .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, MessagingChannel)), ); cmd = addCustomer(cmd, customer); cmd = addMessage(cmd, message); const req = new AppToServerCommand() .setSendMessage(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getSendMessage(); const result = { status: getMessageDeliveryStatusString(res.getStatus()), description: res.getDescription(), sessionId: (res.getSessionId() || { getValue: () =&gt; undefined, }).getValue(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), messageId: (res.getMessageId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Reply to a received message * @param {Customer} customer * @param {string} replyToMessageId * @param {Message} body * @returns {MessageReply} * @ignore */ // eslint-disable-next-line max-len Elarian.prototype._replyToMessage = async function replyToMessage(customer, replyToMessageId, message) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } let { customerId } = customer; if (!customerId) { const state = await customer.getState(); customerId = state.customerId; } let cmd = new ReplyToMessageCommand() .setCustomerId(customerId) .setMessageId(replyToMessageId); cmd = addMessage(cmd, message); const req = new AppToServerCommand() .setReplyToMessage(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getSendMessage(); const result = { status: getStatusString(res.getStatus(), MessageDeliveryStatus), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), messageId: (res.getMessageId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Allow or block a customer from receiving messages from a channel * @param {Customer} customer * @param {MessagingChannelNumber} channelNumber * @param {string} action allow or block * @returns {ConsentUpdateReply} * @ignore */ // eslint-disable-next-line max-len Elarian.prototype._updateMessagingConsent = function updateMessagingConsent(customer, channelNumber, action) { const socket = this.getSocket(); if (!(customer instanceof Customer)) { throw new Error('Invalid customer'); } const { customerNumber } = customer; if (!customerNumber) { // FIXME: Have Elarian return the customer number on fetch state? throw new Error('customerNumber is not setup on this customer'); } let cmd = new UpdateMessagingConsentCommand() .setUpdate(getMessageConsentUpdateAction(action)) .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, MessagingChannel)), ); cmd = addCustomerNumber(cmd, customerNumber); const req = new AppToServerCommand() .setUpdateMessagingConsent(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = AppToServerCommandReply .deserializeBinary(value.data) .getUpdateMessagingConsent(); const result = { status: getStatusString(res.getStatus(), MessagingConsentUpdateStatus), description: res.getDescription(), customerId: (res.getCustomerId() || { getValue: () =&gt; undefined, }).getValue(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Elarian; × Search results Close "},"simulator.js.html":{"id":"simulator.js.html","title":"Source: simulator.js","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Source: simulator.js const Client = require('./client'); const { getStatus, addCashValue, getMediaType, ElarianMessages, getChannelProvider, getCustomerEventDirection, } = require('./utils'); const { Cash, Duration, Timestamp, StringValue, PaymentStatus, PaymentChannel, VoiceCallStatus, UssdSessionStatus, MessagingChannel, MediaMessageBody, EmailMessageBody, InboundMessageBody, UssdInputMessageBody, LocationMessageBody, VoiceCallDialInput, VoiceCallQueueInput, PaymentChannelNumber, VoiceCallHangupCause, MessagingChannelNumber, CustomerEventDirection, SimulatorToServerCommand, VoiceCallInputMessageBody, SimulatorToServerCommandReply, ReceivePaymentSimulatorCommand, ReceiveMessageSimulatorCommand, UpdatePaymentStatusSimulatorCommand, } = ElarianMessages; /** * Instantiate an elarian simulator client * @class * @extends Client * @param {ClientConfig} config */ function Simulator(config) { Client.call(this, { ...config, isSimulator: true }); this.eventListeners = { ...this.eventListeners, sendMessage: null, makeVoiceCall: null, checkoutPayment: null, sendChannelPayment: null, sendCustomerPayment: null, }; } Simulator.prototype = Object.create(Client.prototype, { constructor: Simulator }); /** * Initiate a message request * @param {string} phoneNumber * @param {MessagingChannelNumber} channelNumber * @param {string} sessionId * @param {SimulatorMessageBody[]} parts * @param {Cash} cost * @memberof Simulator */ // eslint-disable-next-line max-len Simulator.prototype.receiveMessage = function receiveMessage(phoneNumber, channelNumber, sessionId, parts = [], cost = { amount: 0, currencyCode: 'KES' }) { const socket = this.getSocket(); const messageParts = parts.map((part) =&gt; { const keys = Object.keys(part); if (keys.includes('text')) { return new InboundMessageBody().setText(part.text); } if (keys.includes('ussd')) { const ussd = new UssdInputMessageBody() .setStatus(getStatus(part.ussd.status, UssdSessionStatus)) .setText(new StringValue().setValue(part.ussd.text)); return new InboundMessageBody().setUssd(ussd); } if (keys.includes('media')) { const mediaObj = new MediaMessageBody() .setUrl(part.media.url) .setMedia(getMediaType(part.media.type)); return new InboundMessageBody().setMedia(mediaObj); } if (keys.includes('location')) { const { label, address, latitude, longitude, } = part.location; const locationObj = new LocationMessageBody() .setLatitude(latitude) .setLongitude(longitude) .setLabel(new StringValue().setValue(label)) .setAddress(new StringValue().setValue(address)); return new InboundMessageBody().setLocation(locationObj); } if (keys.includes('email')) { const { email } = part; const emailObj = new EmailMessageBody() .setSubject(email.subject) .setBodyPlain(email.bodyPlain) .setBodyHtml(email.bodyHtml) .setCcListList(email.ccList) .setBccListList(email.bccList) .setAttachmentsList(email.attachments); return new InboundMessageBody().setEmail(emailObj); } if (keys.includes('voice')) { let dialObj; if (part.voice.dialData) { const { dialData } = part.voice; dialObj = new VoiceCallDialInput() .setDestinationNumber(dialData.destinationNumber) .setStartedAt(new Timestamp().setSeconds(Math.floor(dialData.startedAt))) .setDuration(new Duration().setSeconds(Math.floor(dialData.duration))); } let queueObj; if (part.queueData) { const { queueData } = part.voice; queueObj = new VoiceCallQueueInput() .setEnqueuedAt(new Timestamp().setSeconds(Math.floor(queueData.enqueuedAt))) .setDequeuedAt(new Timestamp().setSeconds(Math.floor(queueData.dequeuedAt))) .setDequeuedToNumber(new StringValue().setValue(queueData.dequeuedToNumber)) // eslint-disable-next-line max-len .setDequeuedToSessionId(new StringValue().setValue(queueData.dequeuedToSessionId)) .setQueueDuration(new Duration().setSeconds(Math.floor(queueData.duration))); } let voiceObj = new VoiceCallInputMessageBody() // eslint-disable-next-line max-len .setDirection(getCustomerEventDirection(part.voice.direction, CustomerEventDirection)) // eslint-disable-next-line max-len .setStartedAt(new Timestamp().setSeconds(Math.floor(part.voice.startedAt || (Date.now() / 1000)))) .setDialData(dialObj) .setQueueData(queueObj); if (part.voice.status) { voiceObj = voiceObj.setStatus(getStatus(part.voice.status, VoiceCallStatus)); } if (part.voice.hangupCause) { voiceObj = voiceObj.setHangupCause(getChannelProvider(part.voice.hangupCause, VoiceCallHangupCause, /^VOICE_CALL_HANGUP_CAUSE_/)); } if (part.voice.dtmfDigits) { // eslint-disable-next-line max-len voiceObj = voiceObj.setDtmlDigits(new StringValue().setValue(part.voice.dtmfDigits)); } if (part.voice.recordingUrl) { // eslint-disable-next-line max-len voiceObj = voiceObj.setRecordingUrl(new StringValue().setValue(part.voice.recordingUrl)); } return new InboundMessageBody().setVoice(voiceObj); } throw new Error(`Invalid message part: ${JSON.stringify(part)}`); }); const cmd = new ReceiveMessageSimulatorCommand() .setCustomerNumber(phoneNumber) .setSessionId(new StringValue().setValue(sessionId)) .setCost(new Cash().setCurrencyCode(cost.currencyCode).setAmount(cost.amount)) .setDuration(new Duration().setSeconds(0)) .setChannelNumber( new MessagingChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, MessagingChannel)), ) .setPartsList(messageParts); const req = new SimulatorToServerCommand() .setReceiveMessage(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = SimulatorToServerCommandReply .deserializeBinary(value.data); const result = { status: res.getStatus(), description: res.getDescription(), message: (res.getMessage() || { toObject: () =&gt; {} }).toObject(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Initiate payment request * @param {string} transactionId * @param {string} customerNumber * @param {PaymentChannelNumber} channelNumber * @param {Cash} value * @param {string} status one of [queued, pending_confirmation, pending_validation, validated, * invalid_request, not_supported, insufficient_funds, application_error, not_allowed, * duplicate_request, invalid_purse, invalid_wallet, decommissioned_customer_id, success, * pass_through, failed, throttled, expired, rejected, reversed] * @memberof Simulator */ // eslint-disable-next-line max-len Simulator.prototype.receivePayment = function receivePayment(transactionId, customerNumber, channelNumber, value, status) { const socket = this.getSocket(); let cmd = new ReceivePaymentSimulatorCommand() .setCustomerNumber(customerNumber) .setTransactionId(transactionId) .setStatus(getStatus(status, PaymentStatus)) .setChannelNumber( new PaymentChannelNumber() .setNumber(channelNumber.number) .setChannel(getChannelProvider(channelNumber.channel, PaymentChannel)), ); cmd = addCashValue(cmd, value); const req = new SimulatorToServerCommand() .setReceivePayment(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: ({ data }) =&gt; { try { const res = SimulatorToServerCommandReply .deserializeBinary(data); const result = { status: res.getStatus(), description: res.getDescription(), message: (res.getMessage() || { toObject: () =&gt; {} }).toObject(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; /** * Update payment status * @param {string} transactionId * @param {string} status * @memberof Simulator */ Simulator.prototype.updatePaymentStatus = function updatePaymentStatus(transactionId, status) { const socket = this.getSocket(); const cmd = new UpdatePaymentStatusSimulatorCommand() .setTransactionId(transactionId) .setStatus(getStatus(status, PaymentStatus)); const req = new SimulatorToServerCommand() .setUpdatePaymentStatus(cmd); return new Promise((resolve, reject) =&gt; { socket .requestResponse({ data: Buffer.from(req.serializeBinary()), }) .subscribe({ onComplete: (value) =&gt; { try { const res = SimulatorToServerCommandReply .deserializeBinary(value.data); const result = { status: res.getStatus(), description: res.getDescription(), message: (res.getMessage() || { toObject: () =&gt; {} }).toObject(), }; resolve(result); } catch (ex) { reject(ex); } }, onError: (error) =&gt; reject(error), }); }); }; module.exports = Simulator; × Search results Close "},"global.html":{"id":"global.html","title":"Global","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Global Type Definitions Activity And object representing a customer activity Type: Object Properties: Name Type Description key string sessionId string properties Object createdAt long Source: utils/types.js, line 395 AuthToken An object representing auth token Type: Object Properties: Name Type Description token string lifetime number in seconds Source: utils/types.js, line 60 Cash An object representing cash Type: Object Properties: Name Type Description amount number currencyCode string Source: utils/types.js, line 177 ChannelPayment An object representing a channel payment source or destination Type: Object Properties: Name Type Description account string channelCode NetworkCode The telco's network code. channelNumber PaymentChannelNumber Source: utils/types.js, line 546 ClientConfig An object representing client params Type: Object Properties: Name Type Argument Description apiKey string appId string orgId string authToken string &lt;optional&gt; received from an client that authenticated with the API key. @see Elarian.generateAuthToken isSimulator boolean &lt;optional&gt; Run this client as a simulator allowNotifications boolean &lt;optional&gt; allow this non-simulator client to receive notifications or not options ConnectionOptions &lt;optional&gt; setup connection options Source: utils/types.js, line 3 ConnectionOptions An object representing config options Type: Object Properties: Name Type Argument Default Description lifetime number &lt;optional&gt; 6000 keepAlive number &lt;optional&gt; 1000 resumable boolean &lt;optional&gt; false notificationTimeout number &lt;optional&gt; 5000 reconnectTimeout number &lt;optional&gt; 60000 serializer Serializer &lt;optional&gt; used to (de)serialize your metadata Source: utils/types.js, line 23 ConsentUpdateReply Type: Object Properties: Name Type Description status string description string customerId string Source: utils/types.js, line 589 CustomerActivityNotification Customer activity notification Type: Notification Properties: Name Type Description sessionId string customerNumber CustomerNumber source string activity Activity Source: utils/types.js, line 386 CustomerNumber An object representing a customer number. Type: Object Properties: Name Type Argument Description number string provider string one of [cellular|telegram|facebook|email|app] partition string &lt;optional&gt; Source: utils/types.js, line 143 CustomerParams An object representing customer params Type: Object Properties: Name Type Argument Default Description customerId string number string provider string &lt;optional&gt; cellular partition string &lt;optional&gt; Source: utils/types.js, line 34 CustomerPayment An object representing a customer's payment source or destination Type: Object Properties: Name Type Description customerNumber CustomerNumber channelNumber PaymentChannelNumber Source: utils/types.js, line 539 CustomerStateUpdateReply Type: Object Properties: Name Type Description customerId string status boolean description string Source: utils/types.js, line 581 Dequeue An object representing a 'dequeue' voice action Type: Object Source: utils/types.js, line 242 Dial An object representing a 'dial' voice action Type: Object Properties: Name Type Description customerNumbers Array.&lt;CustomerNumber&gt; record boolean sequential boolean ringbackTone string callerId string maxDuration number Source: utils/types.js, line 208 Email An object representing email Type: Object Properties: Name Type Description subject string bodyPlain string bodyHtml string ccList Array.&lt;string&gt; bccList Array.&lt;string&gt; Source: utils/types.js, line 167 Enqueue An object representing a 'enqueue' voice action Type: Object Source: utils/types.js, line 235 Event An string representing an event. Must be one of: Connection Events: error: Emitted on connection error closed: Emitted on connection closed pending: Emitted when not connected connected: Emitted on connection success connecting: Emitted when connecting App Events reminder: @see ReminderNotification voiceCall: @see VoiceCallNotification messageStatus: @see MessageStatusNotification ussdSession: @see UssdSessionNotification receivedSms: @see ReceivedSmsNotification receivedEmail: @see ReceivedMediaNotification receivedFbMessenger: @see ReceivedMediaNotification receivedTelegram: @see ReceivedMediaNotification receivedWhatsapp: @see ReceivedMediaNotification paymentStatus: @see PaymentStatusNotification receivedPayment: @see ReceivedPaymentNotification customerActivity: @see CustomerActivityNotification walletPaymentStatus: @see WalletPaymentStatusNotification sentMessageReaction: @see SentMessageReactionNotification messagingSessionEnded: @see MessagingSessionEndedNotification messagingConsentUpdate: @see MessagingConsentUpdateNotification messagingSessionStarted: @see MessagingSessionInitializedNotification messagingSessionRenewed: @see MessagingSessionInitializedNotification Sandbox Events sendMessage: @see SendMessageSimulatorNotification makeVoiceCall: @see MakeVoiceCallSimulatorNotification sendCustomerPayment: @see CustomerPaymentSimulatorNotification sendChannelPayment: @see SendChannelPaymentSimulatorNotification checkoutPayment: @see CustomerPaymentSimulatorNotification Type: string Source: utils/types.js, line 442 GetDigits An object representing a 'getDigits' voice action Type: Object Properties: Name Type Argument Description timeout number finishOnKey string numDigits number say Say &lt;optional&gt; play Play &lt;optional&gt; Source: utils/types.js, line 198 GetRecording An object representing a 'getRecording' voice action Type: Object Properties: Name Type Argument Description playBeep boolean trimSilence boolean timeout number maxLength number finishOnKey string say Say &lt;optional&gt; play Play &lt;optional&gt; Source: utils/types.js, line 250 InitiatePaymentReply An obkect representing a paymennt reply Type: Object Properties: Name Type Description status number description string transactionId string debitCustomerId string creditCustomerId string Source: utils/types.js, line 67 Location An object representing location Type: Object Properties: Name Type Description latitude double longitude double label string address string Source: utils/types.js, line 158 Media An object representing media Type: Object Properties: Name Type Description url string type string one of [image|video|audio|document|voice|sticker|contact] Source: utils/types.js, line 151 Message An object representing a message Type: Object Properties: Name Type Argument Description body MessageBody labels Array.&lt;string&gt; &lt;optional&gt; providerTag string &lt;optional&gt; replyToken string &lt;optional&gt; replyPrompt ReplyPrompt &lt;optional&gt; Source: utils/types.js, line 85 MessageBody An object representing a message body Type: Object Properties: Name Type Argument Description text string &lt;optional&gt; template Template &lt;optional&gt; media Media &lt;optional&gt; location Location &lt;optional&gt; email Email &lt;optional&gt; url string &lt;optional&gt; ussd UssdMenu &lt;optional&gt; voice Array.&lt;VoiceAction&gt; &lt;optional&gt; Source: utils/types.js, line 95 MessageReply Type: Object Properties: Name Type Description status string one of [queued, sent, delivered, read, received, session_initiated, failed, no_consent, no_capability, expired, no_session_in_progress, other_session_in_progress, invalid_reply_token, invalid_channel_number, not_supported, invalid_reply_to_message_id, invalid_customer_id, duplicate_request , tag_not_found, customer_number_not_found, decommissioned_customerid, rejected, invalid_request, application_error] description string customerId string sessionId string messageId string Source: utils/types.js, line 597 MessageStatusNotification Message status notification Type: Notification Properties: Name Type Description messageId string status string one of [queued, sent, delivered, read, received, session_initiated, failed, no_consent, no_capability, expired, no_session_in_progress, other_session_in_progress, invalid_reply_token, invalid_channel_number, not_supported, invalid_reply_to_message_id, invalid_customer_id, duplicate_request , tag_not_found, customer_number_not_found, decommissioned_customerid, rejected, invalid_request, insufficient_credits, application_error] Source: utils/types.js, line 319 MessagingChannelNumber An object representing a messaging channel number Type: Object Properties: Name Type Description number string channel string one of [sms,telegram,whatsapp,email,messenger,voice] Source: utils/types.js, line 574 MessagingConsentUpdateNotification Messaging consent update notification Type: Notification Properties: Name Type Description sessionId string customerNumber CustomerNumber channelNumber MessagingChannelNumber update string one of [allow, block] status string one of [queued, completed, invalid_channel_number, decommissioned_customer_id, application_error] Source: utils/types.js, line 432 MessagingSessionEndedNotification Messaging session ended notification Type: Notification Properties: Name Type Description sessionId string customerNumber CustomerNumber channelNumber MessagingChannelNumber duration number in seconds reason string one of [normal_clearing, inactivity, failure] Source: utils/types.js, line 413 MessagingSessionInitializedNotification Messaging session initialized notification Type: Notification Properties: Name Type Description sessionId string customerNumber CustomerNumber channelNumber MessagingChannelNumber expiresAt number timestamp in seconds Source: utils/types.js, line 423 NetworkCode An number representing a network code. Examples include: 62006: AirtelTigo Ghana62002: Vodafone Ghana62001: MTN Ghana62120: Airtel Nigeria62130: MTN Nigeria62150: Glo Nigeria62160: Etisalat Nigeria63510: MTN Rwanda63513: Tigo Rwanda63514: Airtel Rwanda63601: EthioTelecom Ethiopia63902: Safaricom Kenya63903: Airtel Kenya63907: Orange Kenya63999: Equitel Kenya64002: Tigo Tanzania64004: Vodacom Tanzania64005: Airtel Tanzania64101: Airtel Uganda64110: MTN Uganda64114: Africell Uganda64501: Airtel Zambia64502: MTN Zambia65001: TNM Malawi65010: Airtel Malawi65501: Vodacom South Africa65502: Telkom South Africa65507: CellC South Africa65510: MTN South Africa99999: Athena (This is a custom networkCode that only applies when working in the sandbox environment). Type: number Source: utils/types.js, line 607 Notification An object representing the notification data Type: Object Properties: Name Type Description orgId string appId string customerId string createdAt long Source: utils/types.js, line 276 NotificationCallback( [message] [, appData]) Notification callback Parameters: Name Type Argument Default Description message MessageBody &lt;optional&gt; null appData Object &lt;optional&gt; null Source: utils/types.js, line 285 Returns: Type void NotificationHandler(notification, customer [, callback]) A function that reacts to events Parameters: Name Type Argument Description notification Notification customer Customer callback NotificationCallback &lt;optional&gt; A response to the event. Required for voice and ussd events Source: utils/types.js, line 293 Returns: Type void PaymentChannelNumber An object representing a payment channel Type: Object Properties: Name Type Description number string channel string number provider. Must be one of ['cellular', 'airtime'] Source: utils/types.js, line 567 PaymentStatusNotification Payment status notification Type: Notification Properties: Name Type Argument Description purseId string &lt;optional&gt; transactionId string status string one of [queued, pending_confirmation, pending_validation, validated, invalid_request, not_supported, insufficient_funds, application_error, not_allowed, duplicate_request, invalid_purse, invalid_wallet, decommissioned_customer_id, success, failed, throttled, expired, rejected, reversed] Source: utils/types.js, line 359 Play An object representing a 'play' voice action Type: Object Properties: Name Type Description url string Source: utils/types.js, line 192 PromptMenuItem An object representing a message reply prompt Type: Object Properties: Name Type Argument Description text string &lt;optional&gt; media Media &lt;optional&gt; Source: utils/types.js, line 115 Purse An object representing purse Type: Object Properties: Name Type Description purseId string Source: utils/types.js, line 561 ReceivedMediaNotification Whatsapp, telegram or email notification Type: Notification Properties: Name Type Argument Description messageId string customerNumber CustomerNumber channel MessagingChannelNumber sessionnId string inReplyTo string &lt;optional&gt; text string &lt;optional&gt; media Media &lt;optional&gt; location Location &lt;optional&gt; email Email &lt;optional&gt; Source: utils/types.js, line 345 ReceivedPaymentNotification Payment status notification Type: Notification Properties: Name Type Description purseId string transactionId string customerNumber CustomerNumber channelNumber PaymentChannelNumber value Cash status string one of [queued, pending_confirmation, pending_validation, validated, invalid_request, not_supported, insufficient_funds, application_error, not_allowed, duplicate_request, invalid_purse, invalid_wallet, decommissioned_customer_id, success, failed, throttled, expired, rejected, reversed] Source: utils/types.js, line 367 ReceivedSmsNotification SMS notification Type: Notification Properties: Name Type Description messageId string customerNumber CustomerNumber channel MessagingChannelNumber text string Source: utils/types.js, line 336 RecordSession An object representing a 'recordSession' voice action Type: Object Source: utils/types.js, line 219 Redirect An object representing a 'redirect' voice action Type: Object Properties: Name Type Description url string Source: utils/types.js, line 229 Reject An object representing a 'reject' voice action Type: Object Source: utils/types.js, line 224 Reminder An object representing a reminder Type: Object Properties: Name Type Argument Description key string remindAt number timestamp in seconds e.g 1615361861 payload string interval number &lt;optional&gt; duration in seconds e.g. 60 Source: utils/types.js, line 51 ReminderNotification Reminder notification Type: Notification Properties: Name Type Description reminder Reminder tag Tag workId string Source: utils/types.js, line 302 ReplyPrompt An object representing a message reply prompt Type: Object Properties: Name Type Description action string text, phone_number, email, location, url menu Array.&lt;PromptMenuItem&gt; Source: utils/types.js, line 129 Say An object representing a 'say' voice action Type: Object Properties: Name Type Argument Description text string playBeep boolean &lt;optional&gt; voice male | female &lt;optional&gt; Source: utils/types.js, line 184 SecondaryId An object representing a secondary id. Secondary Ids can be used to add some more unique identities to a customer. e.g. driver's license, etc. Type: Object Properties: Name Type Description key string value string Source: utils/types.js, line 136 SentMessageReactionNotification Message reaction notification Type: Notification Properties: Name Type Description messageId string customerNumber CustomerNumber channelNumber MessagingChannelNumber reaction string one of [clicked, unsubscribed, complained] Source: utils/types.js, line 404 Serializer An object representing serializer Type: Object Properties: Name Type Description type text | binary serialize function deserialize function Source: utils/types.js, line 15 SimulatorMessageBody An object representing a message body Type: Object Properties: Name Type Argument Description text string &lt;optional&gt; media Media &lt;optional&gt; location Location &lt;optional&gt; email Email &lt;optional&gt; ussd UssdInput &lt;optional&gt; voice VoiceCallInput &lt;optional&gt; Source: utils/types.js, line 489 Tag An object representing a tag. Tags can be used to group customers based on some similarities. e.g. loan defaulters, etc. Type: Object Properties: Name Type Argument Description key string value string expiresAt number &lt;optional&gt; timestamp in seconds. e.g. 1615361861 Source: utils/types.js, line 43 TagUpdateReply Type: Object Properties: Name Type Description status boolean description string workId string Source: utils/types.js, line 77 Template An object representing a text template Type: Object Properties: Name Type Description id string params Object Source: utils/types.js, line 122 UssdInput An object representing a ussd input Type: Object Properties: Name Type Description text string status string one of [active, incomplete, completed, app_error] Source: utils/types.js, line 500 UssdMenu An object representing a ussd menu Type: Object Properties: Name Type Description text string isTerminal boolean Source: utils/types.js, line 108 UssdSessionNotification USSD session notification Type: Notification Properties: Name Type Description messageId string sessionId string customerNumber CustomerNumber channel MessagingChannelNumber input UssdInput Source: utils/types.js, line 326 VoiceAction An object representing a voice action. Note: Only one action is required in the object. Type: Object Properties: Name Type Description say Say play Play dial Dial recordSession RecordSession getRecording GetRecording enqueue Enqueue dequeue Dequeue reject Reject redirect Redirect Source: utils/types.js, line 262 VoiceCallDialInput An object representing a voice call dial input Type: Object Properties: Name Type Description destinationNumber string startedAt number duration number Source: utils/types.js, line 520 VoiceCallInput An object representing a voice call input Type: Object Properties: Name Type Description direction string one of [outbound, inbound] status string one of [queued, answered, ringing, active, dialing, dial_completed, bridged, enqueued, dequeued, transferred, transfer_completed, completed, insufficient_credit, not_answered, invalid_phone_number, destination_not_supported, decommissioned_customerid, expired, invalid_channel_number, application_error] startedAt number hangupCause string one of [unallocated_number, user_busy, normal_clearing, no_user_response, no_answer, subscriber_absent, call_rejected, normal_unspecified, normal_temporary_failure, service_unavailable, recovery_on_timer_expire, originator_cancel, lose_race, user_not_registered] dtmfDigits string recordingUrl string dialData VoiceCallDialInput queueData VoiceCallQueueInput Source: utils/types.js, line 507 VoiceCallNotification Voice call notification Type: Notification Properties: Name Type Description messageId string customerNumber CustomerNumber channel MessagingChannelNumber voice VoiceCallInput Source: utils/types.js, line 310 VoiceCallQueueInput An object representing a voice call queue input Type: Object Properties: Name Type Description destinationNumber string enqueuedAt number dequeuedAt number dequeuedToNumber string dequeuedToSessionId string queueDuration number Source: utils/types.js, line 528 Wallet An object representing wallet Type: Object Properties: Name Type Description customerId string walletId string Source: utils/types.js, line 554 WalletPaymentStatusNotification Wallet payment status notification Type: Notification Properties: Name Type Description walletId string transactionId string status string one of [queued, pending_confirmation, pending_validation, validated, invalid_request, not_supported, insufficient_funds, application_error, not_allowed, duplicate_request, invalid_purse, invalid_wallet, decommissioned_customer_id, success, failed, throttled, expired, rejected, reversed] Source: utils/types.js, line 378 × Search results Close "},"classes.list.html":{"id":"classes.list.html","title":"Classes","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Classes Classes Client Customer Elarian Customer Simulator × Search results Close "},"index.html":{"id":"index.html","title":"Index","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Elarian A framework that helps you build scalable, personalized customer engagement applications. Install You can install the package from npm by running: $ npm install elarian Usage // on node const { Elarian } = require('elarian'); /* or in the browser &lt;script src=\"web.js\"&gt;&lt;/script&gt; // or import { Elarian } from 'elarian/web' */ // ... const elarian = new Elarian({ apiKey: 'YOUR_API_KEY', // or authToken: 'YOUR_AUTH_TOKEN' orgId: 'YOUR_ORG_ID', appId: 'YOUR_APP_ID', }); elarian .on('connected', async () =&gt; { console.log('App is running!'); const customer = new client.Customer({ number: '+XXXXXXXXXXXX', provider: 'cellular' }); const state = await customer.getState(); console.log(state); await customer.updateMetadata({ name: 'alice', age: 25 }); const { name } = await customer.getMetadata(); await customer.sendMessage({ number: 'MyAPP', channel: 'sms' }, { body: { text: `Hi ${name}, how are you?` }}); }) .on('error', (error) =&gt; { console.error(error); }) .connect(); See example for a full sample app. Documentation Take a look at the product documentation. For detailed info on this SDK, see the reference. Development Run all tests: $ npm install $ npm test See SDK Spec for reference. Issues If you find a bug, please file an issue on our issue tracker on GitHub. Known Issues resumable connection options prevents app from connecting × Search results Close "},"Client.html":{"id":"Client.html","title":"Class: Client","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Class: Client Client new Client(config) Instantiate an elarian client. You have to call connect() on then client to start using it Parameters: Name Type Description config ClientConfig Source: client.js, line 51 Methods connect() Connecto to elarian servers Source: client.js, line 130 Returns: this instance Type Elarian disconnect() Disconnect from the elarian server Source: client.js, line 191 isConnected() Check if client is connected Source: client.js, line 184 Returns: Type boolean on(event, handler) Register a listener to watch out for events. Can also be called with client.registerListerner(event,listener) Parameters: Name Type Description event Event The event whose listener to register handler NotificationHandler A function that reacts to events Source: client.js, line 605 Returns: this instance Type Client registerNotificationHandler(event, handler) Register a listener to watch out for events. Can also be called with client.on(event,listener) Parameters: Name Type Description event Event The event whose listener to register handler NotificationHandler A function that reacts to events Source: client.js, line 590 Returns: this instance Type Client × Search results Close "},"Customer.html":{"id":"Customer.html","title":"Class: Customer","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Class: Customer Customer new Customer(params) A customer is your end-user, represented by a number (from a cellular, facebook or telegram) Parameters: Name Type Description params CustomerParams Source: customer.js, line 16 Methods addReminder(reminder) Set a reminder to be triggered at the specified time for a particular customer Parameters: Name Type Description reminder Reminder Source: customer.js, line 239 Returns: Type CustomerStateUpdateReply adoptState(otherCustomer) Merge otherCustomer's state into this customer's state and discard otherCustomer Parameters: Name Type Description otherCustomer Customer Source: customer.js, line 101 Returns: Type CustomerStateUpdateReply cancelReminder(key) Cancels a previously set reminder with the key key on the customer Parameters: Name Type Description key string Source: customer.js, line 246 Returns: Type CustomerStateUpdateReply deleteAppData() Remove customer's app data Source: customer.js, line 159 Returns: Type CustomerStateUpdateReply deleteMetadata(keys) Remove some metadata from a customer. keys is an array of strings Parameters: Name Type Description keys Array.&lt;string&gt; Source: customer.js, line 184 Returns: Type CustomerStateUpdateReply deleteSecondaryIds(secondaryIds) Remove some secondary Ids from a customer Parameters: Name Type Description secondaryIds Array.&lt;SecondaryId&gt; Source: customer.js, line 209 Returns: Type CustomerStateUpdateReply deleteTags(tags) Remove some tags from a customer Parameters: Name Type Description tags Array.&lt;string&gt; Source: customer.js, line 232 Returns: Type CustomerStateUpdateReply getMetadata() Fetch customer metadata Source: customer.js, line 165 Returns: Type Object getSecondaryIds() Fetch customer secondaryIds Source: customer.js, line 190 Returns: Type Array.&lt;SecondaryId&gt; getState() Fetch the customer's current state. Source: customer.js, line 72 Returns: Type CustomerState getTags() Fetch customer tags Source: customer.js, line 215 Returns: Type Array.&lt;Tag&gt; leaseAppData() Fetches the customer's app data and lock it from fetching(for up to 90s) until next call to update app data. Source: customer.js, line 144 Returns: Type LeasedAppData replyToMessage(messageId, message) Reply to a message Parameters: Name Type Description messageId string message Message Source: customer.js, line 119 Returns: Type MessageReply sendMessage(channelNumber, message) Send a message to the customer from the specified channel number. Parameters: Name Type Description channelNumber MessagingChannelNumber message Message Source: customer.js, line 110 Returns: Type MessageReply updateActivity(source, activity) Initiate a customer activity Parameters: Name Type Description source string activity Activity Source: customer.js, line 128 Returns: Type CustomerStateUpdateReply updateAppData(data) Sets some app data on the customer. Values in the data object can either be strings or buffers, depending on the set serializer. @see ConnectionOptions Parameters: Name Type Description data Object Source: customer.js, line 153 Returns: Type CustomerStateUpdateReply updateMessagingConsent(channelNumber, action) Allow or block a customer from receiving messages from a channel Parameters: Name Type Description channelNumber MessagingChannelNumber action string allow or block Source: customer.js, line 137 Returns: Type ConsentUpdateReply updateMetadata(metadata) Sets some metadata on the customer. Values in the metadata object can either be strings or buffers, depending on the set serializer Parameters: Name Type Description metadata Object Source: customer.js, line 177 Returns: Type CustomerStateUpdateReply updateSecondaryIds(secondaryIds) Update a customer's secondary Ids Parameters: Name Type Description secondaryIds Array.&lt;SecondaryId&gt; Source: customer.js, line 201 Returns: Type CustomerStateUpdateReply updateTags(tags) Update a customer's tag list. Parameters: Name Type Description tags Array.&lt;Tag&gt; Source: customer.js, line 225 Returns: Type CustomerStateUpdateReply × Search results Close "},"Elarian.html":{"id":"Elarian.html","title":"Class: Elarian","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Class: Elarian Elarian new Elarian(config) Instantiate an elarian client. You have to call connect() on then client to start using it Parameters: Name Type Description config ClientConfig Source: elarian.js, line 10 Extends Client Classes Customer Methods _createCustomer(customerNumber) Create a customer Parameters: Name Type Description customerNumber * Source: state.js, line 147 Returns: Type CustomerStateUpdateReply addCustomerReminderByTag(tag, reminder) Set a reminder to be triggered at the specified time for customers with the particular tag Parameters: Name Type Description tag Tag reminder Reminder Source: state.js, line 53 Returns: Type TagUpdateReply cancelCustomerReminderByTag(tag, key) Cancels a previously set reminder with tag tag and key key Parameters: Name Type Description tag Tag key string Source: state.js, line 101 Returns: Type TagUpdateReply connect() Connecto to elarian servers Inherited From: Client#connect Source: client.js, line 130 Returns: this instance Type Elarian disconnect() Disconnect from the elarian server Inherited From: Client#disconnect Source: client.js, line 191 generateAuthToken() Generate a short-lived auth token to use instead of apiKey. Used for browser and mobile clients. Source: authentication.js, line 16 Returns: Type AuthToken initiatePayment(debitParty, creditParty, value) Initiate a payment transaction Parameters: Name Type Description debitParty CustomerPayment | Wallet | Purse | ChannelPayment creditParty CustomerPayment | Wallet | Purse | ChannelPayment value Cash Source: payment.js, line 25 Returns: Type InitiatePaymentReply isConnected() Check if client is connected Inherited From: Client#isConnected Source: client.js, line 184 Returns: Type boolean on(event, handler) Register a listener to watch out for events. Can also be called with client.registerListerner(event,listener) Parameters: Name Type Description event Event The event whose listener to register handler NotificationHandler A function that reacts to events Inherited From: Client#on Source: client.js, line 605 Returns: this instance Type Client registerNotificationHandler(event, handler) Register a listener to watch out for events. Can also be called with client.on(event,listener) Parameters: Name Type Description event Event The event whose listener to register handler NotificationHandler A function that reacts to events Inherited From: Client#registerNotificationHandler Source: client.js, line 590 Returns: this instance Type Client sendMessageByTag(tag, channelNumber, message) Send message by tag Parameters: Name Type Description tag Tag channelNumber MessagingChannelNumber message Message Source: messaging.js, line 38 Returns: Type TagUpdateReply × Search results Close "},"Elarian_Customer.html":{"id":"Elarian_Customer.html","title":"Class: Customer","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Class: Customer Elarian# Customer new Customer() A customer object. @see Customer Source: elarian.js, line 44 × Search results Close "},"Simulator.html":{"id":"Simulator.html","title":"Class: Simulator","body":" Elarian Classes ClientCustomerElarianElarian#CustomerSimulator Global Global Class: Simulator Simulator new Simulator(config) Instantiate an elarian simulator client Parameters: Name Type Description config ClientConfig Source: simulator.js, line 47 Extends Client Methods connect() Connecto to elarian servers Inherited From: Client#connect Source: client.js, line 130 Returns: this instance Type Elarian disconnect() Disconnect from the elarian server Inherited From: Client#disconnect Source: client.js, line 191 isConnected() Check if client is connected Inherited From: Client#isConnected Source: client.js, line 184 Returns: Type boolean on(event, handler) Register a listener to watch out for events. Can also be called with client.registerListerner(event,listener) Parameters: Name Type Description event Event The event whose listener to register handler NotificationHandler A function that reacts to events Inherited From: Client#on Source: client.js, line 605 Returns: this instance Type Client receiveMessage(phoneNumber, channelNumber, sessionId, parts, cost) Initiate a message request Parameters: Name Type Description phoneNumber string channelNumber MessagingChannelNumber sessionId string parts Array.&lt;SimulatorMessageBody&gt; cost Cash Source: simulator.js, line 73 receivePayment(transactionId, customerNumber, channelNumber, value, status) Initiate payment request Parameters: Name Type Description transactionId string customerNumber string channelNumber PaymentChannelNumber value Cash status string one of [queued, pending_confirmation, pending_validation, validated, invalid_request, not_supported, insufficient_funds, application_error, not_allowed, duplicate_request, invalid_purse, invalid_wallet, decommissioned_customer_id, success, pass_through, failed, throttled, expired, rejected, reversed] Source: simulator.js, line 231 registerNotificationHandler(event, handler) Register a listener to watch out for events. Can also be called with client.on(event,listener) Parameters: Name Type Description event Event The event whose listener to register handler NotificationHandler A function that reacts to events Inherited From: Client#registerNotificationHandler Source: client.js, line 590 Returns: this instance Type Client updatePaymentStatus(transactionId, status) Update payment status Parameters: Name Type Description transactionId string status string Source: simulator.js, line 280 × Search results Close "}}
    </script>

    <script type="text/javascript">
        $(document).ready(function() {
            Searcher.init();
        });

        $(window).on("message", function(msg) {
            var msgData = msg.originalEvent.data;

            if (msgData.msgid != "docstrap.quicksearch.start") {
                return;
            }

            var results = Searcher.search(msgData.searchTerms);

            window.parent.postMessage({"results": results, "msgid": "docstrap.quicksearch.done"}, "*");
        });
    </script>
</body>
</html>
